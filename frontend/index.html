<!doctype html>
<html lang="ru">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Lumica Mini App</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style>
        :root {
            font-family: "Inter", "Segoe UI", system-ui, sans-serif;
            background-color: #030712;
            color: #f4f5f7;
            --safe-top: env(safe-area-inset-top, 0px);
            --safe-bottom: env(safe-area-inset-bottom, 0px);
            --system-top-reserve: 0px;
            --system-nav-reserve: 0px;
            --app-top-offset: calc(var(--safe-top) + var(--system-top-reserve));
            --app-bottom-offset: calc(var(--safe-bottom) + var(--system-nav-reserve));
        }

        * {
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        button,
        [role="button"],
        a {
            -webkit-tap-highlight-color: transparent;
        }

        button:focus:not(:focus-visible),
        [role="button"]:focus:not(:focus-visible),
        a:focus:not(:focus-visible) {
            outline: none;
        }

        html, body {
            height: 100%;
            width: 100%;
            max-width: 100%;
            overflow-x: hidden;
        }

        body {
            margin: 0;
            min-height: 100vh;
            width: 100%;
            max-width: 100%;
            overflow-x: hidden;
            background: radial-gradient(circle at 50% -10%, rgba(99, 140, 255, 0.18), rgba(5, 10, 25, 0.85) 42%), linear-gradient(145deg, #0b1224, #090f1f 55%);
            color: #f4f5f7;
        }

        main {
            width: 100%;
            max-width: 100%;
            min-height: 100vh;
            padding: calc(1.2rem + var(--app-top-offset)) 1rem 1rem;
            overflow-x: hidden;
            opacity: 0;
            transition: opacity 0.45s ease;
        }

        main.visible {
            opacity: 1;
        }

        .content {
            width: 100%;
            max-width: 540px;
            margin: 0 auto;
            padding-bottom: calc(110px + var(--app-bottom-offset));
            min-width: 0;
            overflow-x: hidden;
        }
        .app-content,
        .app-shell {
            width: 100%;
            max-width: 100%;
            min-width: 0;
            overflow-x: hidden;
        }

        .status-card,
        .app-content {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        .status-card {
            padding: 1.75rem;
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 18px;
            align-items: flex-start;
            background: rgba(7, 12, 24, 0.75);
        }

        .app-shell {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .topbar {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0.2rem 0.4rem;
            color: #e9ecf5;
            letter-spacing: 0.03em;
            font-weight: 700;
            font-size: 1.05rem;
            text-transform: uppercase;
        }

        .topbar .icon {
            display: none;
        }

        .hero-card {
            position: relative;
            border-radius: 24px;
            overflow: hidden;
            padding: 1.4rem 1.2rem 1.1rem;
            background: radial-gradient(circle at 50% 10%, rgba(92, 174, 255, 0.15), rgba(33, 16, 54, 0.05) 35%, rgba(7, 11, 26, 0.72) 100%);
            border: 1px solid rgba(255, 255, 255, 0.06);
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.35);
        }

        .hero-card .orb-hero {
            position: relative;
            width: 180px;
            height: 180px;
            margin: 0 auto 0.8rem;
            filter: drop-shadow(0 12px 30px rgba(0,0,0,0.45));
        }

        .hero-icon {
            width: 180px;
            height: 180px;
            display: block;
            margin: 0 auto;
        }

        .hero-caption {
            text-align: center;
            color: #cfe8ff;
            font-weight: 700;
            letter-spacing: 0.02em;
            text-shadow: 0 4px 18px rgba(0,0,0,0.4);
        }

        .hero-sub {
            text-align: center;
            color: rgba(207, 232, 255, 0.8);
            margin-top: 0.15rem;
            font-size: 0.85rem;
        }

        .cards {
            display: flex;
            flex-direction: column;
            gap: 0.8rem;
        }

        .card {
            position: relative;
            padding: 1rem 1rem;
            border-radius: 18px;
            background: linear-gradient(135deg, rgba(28, 46, 74, 0.65), rgba(18, 25, 44, 0.92));
            border: 1px solid rgba(255, 255, 255, 0.06);
            box-shadow: 0 14px 40px rgba(0,0,0,0.28);
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 0.75rem;
        }

        .card .left {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .badge {
            min-width: 32px;
            min-height: 32px;
            border-radius: 12px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            background: radial-gradient(circle at 30% 30%, #6cf6ff, #1d9bff);
            box-shadow: 0 0 16px rgba(33, 190, 255, 0.45);
            color: #03223b;
            font-weight: 700;
        }

        .card-title {
            color: #eef4ff;
            font-weight: 700;
            letter-spacing: 0.01em;
        }

        .card-sub {
            color: rgba(230, 240, 255, 0.7);
            font-size: 0.92rem;
        }
        .profile-nav-select {
            min-width: 9.6rem;
            border: 1px solid rgba(120, 182, 255, 0.4);
            border-radius: 10px;
            background: rgba(14, 26, 50, 0.92);
            color: #eef6ff;
            font-size: 0.86rem;
            line-height: 1.25;
            padding: 0.38rem 0.52rem;
        }
        .profile-nav-select:focus {
            outline: 2px solid rgba(133, 194, 255, 0.92);
            outline-offset: 2px;
        }

        .chevron {
            color: rgba(230, 240, 255, 0.7);
        }
        .connection-protocol-btn {
            width: 100%;
            text-align: left;
            font: inherit;
            color: inherit;
            cursor: pointer;
        }
        .home-main-actions {
            display: grid;
            gap: 0.8rem;
            margin-top: 0.1rem;
        }
        .home-main-btn {
            width: 100%;
            text-align: left;
            font: inherit;
            color: inherit;
            cursor: pointer;
            border: 1px solid rgba(255, 255, 255, 0.08);
        }
        .home-main-btn:active {
            transform: translateY(1px);
        }
        .home-main-btn.active {
            border-color: rgba(120, 184, 255, 0.5);
            box-shadow: inset 0 0 0 1px rgba(120, 184, 255, 0.25), 0 14px 34px rgba(0, 0, 0, 0.3);
        }
        .connection-protocol-btn:active {
            transform: translateY(1px);
        }
        .connection-pages {
            display: grid;
            gap: 0.8rem;
        }
        .connections-detail-list {
            display: grid;
            gap: 0.55rem;
        }
        .connections-detail-info {
            border: 1px solid rgba(133, 188, 255, 0.34);
            border-radius: 12px;
            background: rgba(23, 38, 66, 0.62);
            color: #e5f1ff;
            padding: 0.62rem 0.72rem;
            font-size: 0.82rem;
            line-height: 1.35;
            white-space: pre-wrap;
            overflow-wrap: anywhere;
        }
        .connection-item {
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 12px;
            background: rgba(11, 18, 34, 0.82);
            padding: 0.64rem 0.72rem;
        }
        .connection-item-title {
            color: #edf6ff;
            font-weight: 700;
            font-size: 0.84rem;
            line-height: 1.25;
        }
        .connection-item-meta {
            margin-top: 0.2rem;
            display: grid;
            gap: 0.1rem;
            color: rgba(219, 234, 255, 0.74);
            font-size: 0.78rem;
            line-height: 1.35;
        }
        .connection-copy-row {
            margin-top: 0.45rem;
            display: flex;
            gap: 0.35rem;
            flex-wrap: wrap;
        }
        .connection-copy-btn {
            border: 1px solid rgba(120, 171, 255, 0.42);
            background: rgba(28, 44, 80, 0.9);
            color: #edf6ff;
            border-radius: 8px;
            padding: 0.3rem 0.52rem;
            font-size: 0.76rem;
            font-weight: 700;
            cursor: pointer;
        }
        .connection-copy-btn:active {
            transform: translateY(1px);
        }

        .section-title {
            margin: 0.2rem 0 0.3rem;
            color: #e6ecf7;
            font-weight: 700;
            letter-spacing: 0.02em;
        }

        .pill-soft {
            padding: 0.4rem 0.75rem;
            border-radius: 999px;
            background: linear-gradient(135deg, rgba(79, 123, 255, 0.28), rgba(95, 237, 255, 0.22));
            color: #dce9ff;
            font-size: 0.9rem;
            border: 1px solid rgba(255,255,255,0.08);
        }

        .support-card {
            text-align: center;
            font-weight: 700;
        }

        .bottom-nav {
            position: fixed;
            left: max(0.5rem, env(safe-area-inset-left, 0px));
            right: max(0.5rem, env(safe-area-inset-right, 0px));
            bottom: calc(8px + var(--app-bottom-offset));
            width: auto;
            max-width: 560px;
            margin-inline: auto;
            padding: 0.35rem;
            border-radius: 16px;
            background: rgba(12, 18, 33, 0.92);
            border: 1px solid rgba(255, 255, 255, 0.06);
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 0.25rem;
            box-shadow: 0 18px 40px rgba(0, 0, 0, 0.35);
            backdrop-filter: blur(12px);
        }
        .bottom-nav.with-work {
            grid-template-columns: repeat(4, 1fr);
        }
        .bottom-nav.cloud-hidden {
            grid-template-columns: repeat(3, 1fr);
        }
        .bottom-nav.with-work.cloud-hidden {
            grid-template-columns: repeat(4, 1fr);
        }

        .nav-btn {
            border: none;
            background: transparent;
            color: rgba(220, 232, 255, 0.8);
            padding: 0.65rem 0.4rem;
            border-radius: 12px;
            display: flex;
            flex-direction: column;
            gap: 0.15rem;
            align-items: center;
            font-size: 0.92rem;
            cursor: pointer;
            transition: background 0.2s ease, color 0.2s ease, transform 0.15s;
        }

        .nav-btn .icon {
            font-size: 1.05rem;
        }
        .nav-btn span:last-child {
            font-size: 0.84rem;
            line-height: 1.12;
            white-space: nowrap;
        }

        .nav-btn.active {
            background: linear-gradient(135deg, rgba(64, 224, 255, 0.2), rgba(122, 89, 255, 0.2));
            color: #f5fbff;
            box-shadow: inset 0 0 0 1px rgba(255,255,255,0.08), 0 6px 16px rgba(0,0,0,0.25);
            transform: translateY(-1px);
        }

        .screen {
            display: flex;
            flex-direction: column;
            gap: 0.8rem;
            width: 100%;
            min-width: 0;
            max-width: 100%;
            overflow-x: hidden;
        }
        #screen-work {
            width: 100%;
            margin-left: 0;
            margin-right: 0;
            padding-inline: 0;
            padding-top: 0.2rem;
            box-sizing: border-box;
            align-items: stretch;
        }
        #screen-connections {
            width: 100%;
            margin-left: 0;
            margin-right: 0;
            padding-inline: 0;
            padding-top: 0.6rem;
            box-sizing: border-box;
            align-items: stretch;
        }
        #screen-cloud {
            width: 100%;
            max-width: 100%;
            margin-left: 0;
            margin-right: 0;
            padding-inline: 0;
            padding-top: 0.25rem;
            box-sizing: border-box;
            align-items: stretch;
            overflow-x: hidden;
        }
        #screen-profile {
            padding-top: 0.55rem;
        }
        .work-page {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
            padding: 0.9rem;
            border-radius: 16px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            background: rgba(13, 18, 31, 0.78);
        }
        #work-menu-page {
            width: 100%;
            padding: 0;
            border: none;
            background: transparent;
        }
        #screen-work .section-title {
            width: 100%;
        }
        .work-page-title {
            color: #eaf2ff;
            font-size: 1rem;
            font-weight: 700;
            letter-spacing: 0.01em;
        }
        .work-page-head {
            display: flex;
            align-items: center;
            justify-content: space-between;
            flex-wrap: wrap;
            gap: 0.6rem;
        }
        #screen-work .work-page-head .work-page-title {
            display: none;
        }
        #screen-connections .work-page-head .work-page-title {
            display: none;
        }
        .work-page-context {
            display: flex;
            justify-content: center;
            position: relative;
            z-index: 6;
            margin-top: 0;
            margin-bottom: 0.45rem;
            pointer-events: none;
        }
        .work-page-context.clickable {
            pointer-events: auto;
        }
        body.context-near-system-bar .work-page-context {
            position: fixed;
            top: calc(var(--safe-top) + 0.55rem);
            left: 50%;
            transform: translateX(-50%);
            z-index: 1200;
            width: fit-content;
            max-width: min(18rem, calc(100vw - 9rem));
            margin: 0;
        }
        body.context-near-system-bar .work-page-pill {
            max-width: 100%;
        }
        .work-page-context.clickable .work-page-pill {
            cursor: pointer;
            pointer-events: auto;
        }
        .work-page-context.clickable .work-page-pill:active {
            transform: translateY(1px);
        }
        .work-page-context.clickable .work-page-pill:focus-visible {
            outline: 2px solid rgba(133, 194, 255, 0.9);
            outline-offset: 2px;
        }
        .work-page-context.hidden {
            display: none;
        }
        .screen-menu-context {
            position: fixed;
            top: calc(var(--safe-top) + 0.55rem);
            left: 50%;
            transform: translateX(-50%);
            z-index: 1180;
            width: fit-content;
            max-width: min(18rem, calc(100vw - 9rem));
            margin: 0;
            pointer-events: none;
            display: flex;
            justify-content: center;
        }
        .screen-menu-context.clickable {
            pointer-events: auto;
        }
        .screen-menu-context.hidden {
            display: none;
        }
        .screen-menu-context .work-page-pill {
            max-width: 100%;
        }
        .screen-menu-context.clickable .work-page-pill {
            cursor: pointer;
            pointer-events: auto;
        }
        .screen-menu-context.clickable .work-page-pill:active {
            transform: translateY(1px);
        }
        .screen-menu-context.clickable .work-page-pill:focus-visible {
            outline: 2px solid rgba(133, 194, 255, 0.9);
            outline-offset: 2px;
        }
        .work-page-pill {
            position: relative;
            display: inline-block;
            max-width: clamp(8rem, 56vw, 18rem);
            padding: 0.34rem 0.78rem 0.34rem 1.34rem;
            border-radius: 999px;
            border: 1px solid rgba(155, 206, 255, 0.45);
            background: rgba(17, 30, 56, 0.92);
            box-shadow: 0 8px 20px rgba(4, 10, 24, 0.45), inset 0 0 0 1px rgba(255, 255, 255, 0.04);
            color: #ebf4ff;
            font-size: 0.82rem;
            font-weight: 700;
            letter-spacing: 0.01em;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            text-align: center;
            pointer-events: none;
            z-index: 0;
        }
        .work-page-pill::before {
            content: "";
            position: absolute;
            left: 0.56rem;
            top: 50%;
            width: 0.44rem;
            height: 0.44rem;
            border-radius: 999px;
            transform: translateY(-50%);
            background: linear-gradient(135deg, #8be7ff, #7d8cff);
            box-shadow: 0 0 10px rgba(125, 140, 255, 0.5);
        }
        .work-back-btn {
            border: 1px solid rgba(255, 255, 255, 0.15);
            background: rgba(18, 26, 44, 0.92);
            color: #dbe9ff;
            border-radius: 10px;
            padding: 0.45rem 0.65rem;
            cursor: pointer;
            font-weight: 700;
        }
        .work-profile-card {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 0.8rem;
            width: 100%;
            padding: 0.9rem;
            border-radius: 16px;
            background: rgba(14, 20, 34, 0.9);
            border: 1px solid rgba(255, 255, 255, 0.08);
        }
        .work-profile-main {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            min-width: 0;
        }
        .work-profile-avatar {
            width: 54px;
            height: 54px;
            border-radius: 999px;
            border: 1px solid rgba(255, 255, 255, 0.15);
            display: inline-flex;
            align-items: center;
            justify-content: center;
            font-size: 1.35rem;
            background: radial-gradient(circle at 30% 30%, rgba(255, 164, 117, 0.28), rgba(35, 42, 60, 0.9));
            flex: 0 0 54px;
        }
        .work-profile-name {
            color: #f3f8ff;
            font-weight: 700;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .work-profile-role {
            margin-top: 0.18rem;
            color: rgba(224, 236, 255, 0.72);
            font-size: 0.84rem;
        }
        .work-menu-groups {
            display: grid;
            width: 100%;
            grid-template-columns: minmax(0, 1fr);
            gap: 0.75rem;
            margin-top: 0.75rem;
        }
        .work-menu-group {
            width: 100%;
            padding: 0.85rem;
            border-radius: 16px;
            border: 1px solid rgba(255, 255, 255, 0.7);
            background: rgba(15, 20, 34, 0.86);
        }
        .work-menu-group-title {
            color: #f4f8ff;
            font-size: 1.05rem;
            font-weight: 700;
            margin-bottom: 0.65rem;
        }
        .work-menu-buttons {
            display: grid;
            gap: 0.6rem;
        }
        .work-menu-btn {
            width: 100%;
            border: 1px solid rgba(120, 171, 255, 0.42);
            background: linear-gradient(135deg, rgba(34, 50, 88, 0.92), rgba(18, 29, 56, 0.96));
            color: #f2f8ff;
            border-radius: 12px;
            padding: 0.8rem 0.75rem;
            text-align: center;
            font-weight: 700;
            cursor: pointer;
            box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.04), 0 8px 18px rgba(7, 16, 35, 0.34);
            transition: transform 0.15s ease, border-color 0.15s ease, box-shadow 0.15s ease;
        }
        .work-menu-btn:active {
            transform: translateY(1px);
            border-color: rgba(132, 227, 255, 0.72);
            box-shadow: inset 0 0 0 1px rgba(186, 236, 255, 0.1), 0 6px 14px rgba(8, 17, 38, 0.32);
        }
        .work-menu-btn:focus-visible {
            outline: none;
            border-color: rgba(132, 227, 255, 0.78);
            box-shadow: 0 0 0 2px rgba(86, 184, 255, 0.22), inset 0 0 0 1px rgba(186, 236, 255, 0.12);
        }
        .work-actions {
            display: grid;
            grid-template-columns: 1fr;
            gap: 0.6rem;
        }
        .work-action-link {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 0.7rem;
            border: 1px solid rgba(142, 198, 255, 0.52);
            background: linear-gradient(135deg, rgba(38, 61, 106, 0.94), rgba(18, 33, 66, 0.98));
            border-radius: 12px;
            padding: 0.78rem 0.82rem;
            cursor: pointer;
            color: #f2f8ff;
            font-weight: 700;
            box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.06), 0 10px 22px rgba(7, 15, 35, 0.35);
            transition: transform 0.15s ease, border-color 0.15s ease, box-shadow 0.15s ease;
        }
        .work-action-link:active {
            transform: translateY(1px);
            border-color: rgba(132, 227, 255, 0.76);
            box-shadow: inset 0 0 0 1px rgba(186, 236, 255, 0.12), 0 7px 16px rgba(8, 17, 38, 0.3);
        }
        .work-action-link:focus-visible {
            outline: none;
            border-color: rgba(132, 227, 255, 0.82);
            box-shadow: 0 0 0 2px rgba(86, 184, 255, 0.24), inset 0 0 0 1px rgba(186, 236, 255, 0.14);
        }
        .work-action-link-label {
            color: #f4f9ff;
            font-size: 0.94rem;
            line-height: 1.2;
        }
        .work-action-link-chevron {
            color: rgba(204, 230, 255, 0.9);
            font-size: 1.08rem;
            line-height: 1;
            font-weight: 800;
            flex: 0 0 auto;
        }
        .work-btn {
            border: 1px solid rgba(120, 171, 255, 0.36);
            background: linear-gradient(135deg, rgba(30, 47, 84, 0.9), rgba(16, 27, 52, 0.95));
            color: #f4f8ff;
            border-radius: 12px;
            padding: 0.75rem 0.7rem;
            cursor: pointer;
            font-weight: 700;
            text-align: left;
            box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.035), 0 8px 16px rgba(7, 15, 34, 0.3);
            transition: transform 0.15s ease, border-color 0.15s ease, box-shadow 0.15s ease;
        }
        .work-btn:active {
            transform: translateY(1px);
            border-color: rgba(132, 227, 255, 0.68);
            box-shadow: inset 0 0 0 1px rgba(186, 236, 255, 0.1), 0 6px 12px rgba(8, 17, 38, 0.28);
        }
        .work-btn:focus-visible {
            outline: none;
            border-color: rgba(132, 227, 255, 0.76);
            box-shadow: 0 0 0 2px rgba(86, 184, 255, 0.2), inset 0 0 0 1px rgba(186, 236, 255, 0.12);
        }
        .work-note {
            font-size: 0.82rem;
            color: rgba(221, 235, 255, 0.72);
            line-height: 1.35;
        }
        .work-note.success {
            color: #a7f3c5;
        }
        .work-note.error {
            color: #ffb8b8;
        }
        .work-client-summary-card {
            padding: 0.85rem 0.95rem;
        }
        .work-client-summary {
            display: grid;
            gap: 0.62rem;
        }
        .work-client-summary-row {
            display: grid;
            gap: 0.14rem;
        }
        .work-client-summary-label {
            color: rgba(192, 215, 255, 0.76);
            font-size: 0.79rem;
        }
        .work-client-summary-value {
            color: #edf6ff;
            font-weight: 700;
            font-size: 0.88rem;
        }
        .work-bind input {
            width: 100%;
            background: rgba(12, 20, 38, 0.9);
            color: #e9f2ff;
            border: 1px solid rgba(255,255,255,0.12);
            border-radius: 10px;
            padding: 0.55rem 0.6rem;
        }
        .work-sub-extend-wrap {
            width: 100%;
            display: grid;
            gap: 0.42rem;
        }
        .work-sub-extend-head {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 0.6rem;
        }
        .work-sub-extend-label {
            color: rgba(207, 226, 255, 0.8);
            font-size: 0.82rem;
        }
        .work-sub-extend-value {
            color: #eef7ff;
            font-size: 0.86rem;
            font-weight: 700;
        }
        .work-sub-extend-range {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 1.5rem;
            margin: 0;
            padding: 0;
            border: none;
            background: transparent;
            touch-action: pan-y;
            --work-sub-progress: 0%;
        }
        .work-sub-extend-range:focus {
            outline: none;
        }
        .work-sub-extend-range::-webkit-slider-runnable-track {
            height: 0.38rem;
            border-radius: 999px;
            background: linear-gradient(
                90deg,
                #56b8ff 0%,
                #56b8ff var(--work-sub-progress),
                rgba(192, 216, 255, 0.28) var(--work-sub-progress),
                rgba(192, 216, 255, 0.28) 100%
            );
        }
        .work-sub-extend-range::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 1.02rem;
            height: 1.02rem;
            margin-top: -0.32rem;
            border-radius: 50%;
            border: 2px solid #56b8ff;
            background: #f3f9ff;
            box-shadow: 0 2px 8px rgba(7, 17, 34, 0.45);
            cursor: pointer;
        }
        .work-sub-extend-range::-moz-range-track {
            height: 0.38rem;
            border: none;
            border-radius: 999px;
            background: rgba(192, 216, 255, 0.28);
        }
        .work-sub-extend-range::-moz-range-progress {
            height: 0.38rem;
            border: none;
            border-radius: 999px;
            background: #56b8ff;
        }
        .work-sub-extend-range::-moz-range-thumb {
            width: 1.02rem;
            height: 1.02rem;
            border-radius: 50%;
            border: 2px solid #56b8ff;
            background: #f3f9ff;
            box-shadow: 0 2px 8px rgba(7, 17, 34, 0.45);
            cursor: pointer;
        }
        .work-sub-create-wrap {
            width: 100%;
            display: grid;
            gap: 0.42rem;
        }
        .work-sub-create-label {
            color: rgba(207, 226, 255, 0.8);
            font-size: 0.82rem;
        }
        .work-sub-create-input {
            color-scheme: dark;
        }
        .work-bind {
            display: grid;
            gap: 0.6rem;
            margin-top: 0.35rem;
        }
        .work-bind select {
            width: 100%;
            background: rgba(12, 20, 38, 0.9);
            color: #e9f2ff;
            border: 1px solid rgba(255,255,255,0.12);
            border-radius: 10px;
            padding: 0.55rem 0.6rem;
        }
        .work-bind-actions {
            display: grid;
            grid-template-columns: repeat(2, minmax(0, 1fr));
            gap: 0.55rem;
        }
        @media (max-width: 420px) {
            .work-bind-actions {
                grid-template-columns: 1fr;
            }
        }
        .work-client-cards,
        .work-links-list {
            display: grid;
            gap: 0.6rem;
        }
        .work-client-card {
            width: 100%;
            border: 1px solid rgba(255, 255, 255, 0.1);
            background: linear-gradient(135deg, rgba(23, 35, 62, 0.88), rgba(14, 20, 38, 0.95));
            color: #eef5ff;
            border-radius: 12px;
            padding: 0.8rem;
            cursor: pointer;
            text-align: left;
        }
        .work-client-card-title {
            font-weight: 700;
            color: #f3f7ff;
        }
        .work-client-card-sub {
            margin-top: 0.2rem;
            color: rgba(221, 235, 255, 0.72);
            font-size: 0.84rem;
        }
        .work-link-item {
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 0.7rem;
            background: rgba(12, 19, 36, 0.86);
        }
        .work-link-item-title {
            color: #eff5ff;
            font-weight: 700;
            font-size: 0.9rem;
        }
        .work-link-item-value {
            margin-top: 0.24rem;
            color: #f5f9ff;
            font-size: 0.85rem;
            line-height: 1.35;
        }
        .work-link-item-sub {
            margin-top: 0.2rem;
            color: rgba(219, 234, 255, 0.72);
            font-size: 0.82rem;
            line-height: 1.35;
        }
        .work-link-clients {
            margin-top: 0.45rem;
            display: grid;
            gap: 0.35rem;
        }
        .work-link-client {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 0.5rem;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 0.48rem 0.55rem;
            background: rgba(16, 25, 46, 0.84);
        }
        .work-link-client-name {
            color: #eef6ff;
            font-size: 0.83rem;
            line-height: 1.3;
            min-width: 0;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        .work-link-client-remove {
            border: 1px solid rgba(255, 107, 107, 0.5);
            background: rgba(120, 25, 37, 0.42);
            color: #ffd7dc;
            border-radius: 8px;
            padding: 0.2rem 0.5rem;
            font-size: 0.78rem;
            font-weight: 700;
            cursor: pointer;
            flex: 0 0 auto;
        }
        .work-link-client-remove:active {
            transform: translateY(1px);
        }
        .work-inbounds-list {
            display: grid;
            gap: 0.55rem;
        }
        .work-inbound-card {
            position: relative;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            background: rgba(12, 19, 36, 0.86);
            padding: 0.75rem 3.1rem 0.72rem 0.75rem;
            display: grid;
            gap: 0.45rem;
        }
        .work-inbound-card.interactive {
            cursor: pointer;
            transition: transform 0.14s ease, border-color 0.14s ease, box-shadow 0.14s ease;
        }
        .work-inbound-card.interactive:active {
            transform: translateY(1px);
            border-color: rgba(132, 227, 255, 0.58);
            box-shadow: 0 8px 18px rgba(5, 14, 32, 0.34);
        }
        .work-inbound-card.interactive:focus-visible {
            outline: none;
            border-color: rgba(132, 227, 255, 0.78);
            box-shadow: 0 0 0 2px rgba(86, 184, 255, 0.22);
        }
        .work-inbound-card.interactive.active {
            border-color: rgba(132, 227, 255, 0.68);
            box-shadow: inset 0 0 0 1px rgba(148, 221, 255, 0.2);
        }
        .work-inbound-head {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 0.6rem;
            flex-wrap: wrap;
        }
        .work-inbound-title {
            color: #eff6ff;
            font-weight: 700;
            font-size: 0.9rem;
            line-height: 1.25;
        }
        .work-inbound-meta {
            color: rgba(219, 234, 255, 0.74);
            font-size: 0.82rem;
            line-height: 1.3;
        }
        .work-inbound-badges {
            display: flex;
            align-items: center;
            gap: 0.26rem;
            position: absolute;
            top: 0.48rem;
            right: 0.48rem;
            z-index: 1;
        }
        .work-inbound-pill {
            width: 1.22rem;
            height: 1.22rem;
            border: 1px solid rgba(255, 255, 255, 0.14);
            border-radius: 7px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 0;
            font-size: 0.74rem;
            line-height: 1;
            color: #e7f1ff;
            background: rgba(28, 41, 68, 0.86);
        }
        .work-inbound-pill.panel-on {
            border-color: rgba(107, 233, 166, 0.58);
            background: rgba(18, 72, 47, 0.42);
            box-shadow: inset 0 0 0 1px rgba(129, 251, 186, 0.24);
        }
        .work-inbound-pill.panel-off {
            border-color: rgba(255, 126, 126, 0.35);
            background: rgba(86, 20, 20, 0.36);
            box-shadow: inset 0 0 0 1px rgba(255, 147, 147, 0.18);
        }
        .work-inbound-pill.visibility-on {
            border-color: rgba(107, 233, 166, 0.58);
            background: rgba(18, 72, 47, 0.42);
            box-shadow: inset 0 0 0 1px rgba(129, 251, 186, 0.24);
        }
        .work-inbound-pill.visibility-off {
            border-color: rgba(255, 214, 112, 0.58);
            background: rgba(92, 64, 15, 0.42);
            box-shadow: inset 0 0 0 1px rgba(255, 228, 156, 0.22);
        }
        .work-inbound-toggle-btn {
            border: 1px solid rgba(126, 189, 255, 0.42);
            border-radius: 10px;
            background: linear-gradient(135deg, rgba(34, 50, 88, 0.92), rgba(18, 29, 56, 0.96));
            color: #f2f8ff;
            padding: 0.48rem 0.6rem;
            font-size: 0.81rem;
            font-weight: 700;
            cursor: pointer;
            text-align: center;
        }
        .work-inbound-toggle-btn:active {
            transform: translateY(1px);
        }
        .work-inbound-detail-actions {
            margin-top: 0.55rem;
        }
        .work-inbound-detail-actions .work-inbound-toggle-btn {
            width: 100%;
            text-align: center;
        }
        .cloud-page {
            display: grid;
            width: 100%;
            max-width: 100%;
            gap: 0.68rem;
            padding: 0.85rem;
            min-width: 0;
            overflow-x: hidden;
        }
        .cloud-toolbar {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 0.55rem;
            flex-wrap: wrap;
        }
        .cloud-path {
            border: 1px solid rgba(126, 189, 255, 0.34);
            border-radius: 10px;
            background: rgba(17, 28, 50, 0.72);
            color: #ecf6ff;
            font-size: 0.82rem;
            line-height: 1.35;
            padding: 0.48rem 0.58rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .cloud-actions {
            display: grid;
            gap: 0.55rem;
            grid-template-columns: repeat(2, minmax(0, 1fr));
            min-width: 0;
            max-width: 100%;
        }
        .cloud-upload-btn {
            display: block;
            width: 100%;
            text-align: center;
            max-width: 100%;
            min-width: 0;
        }
        .cloud-upload-btn.disabled {
            opacity: 0.58;
            pointer-events: none;
        }
        .cloud-upload-progress {
            position: relative;
            width: 100%;
            height: 0.42rem;
            border-radius: 999px;
            border: 1px solid rgba(132, 185, 255, 0.28);
            background: rgba(19, 30, 52, 0.75);
            overflow: hidden;
        }
        .cloud-upload-progress-bar {
            width: 0%;
            height: 100%;
            border-radius: inherit;
            background: linear-gradient(90deg, #56b8ff, #7bdcff);
            box-shadow: 0 0 10px rgba(86, 184, 255, 0.35);
            transition: width 0.16s ease;
        }
        .cloud-upload-progress-text {
            font-size: 0.76rem;
            line-height: 1.2;
            color: rgba(212, 232, 255, 0.82);
            margin-top: -0.12rem;
        }
        .cloud-list {
            display: grid;
            gap: 0.54rem;
            width: 100%;
            max-width: 100%;
            min-width: 0;
        }
        .cloud-node-card {
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            background: rgba(12, 19, 36, 0.88);
            padding: 0.62rem 0.68rem;
            display: grid;
            gap: 0.48rem;
        }
        .cloud-node-head {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 0.52rem;
            min-width: 0;
            max-width: 100%;
        }
        .cloud-node-open {
            border: none;
            background: transparent;
            color: #eef6ff;
            font-weight: 700;
            font-size: 0.86rem;
            line-height: 1.3;
            padding: 0;
            margin: 0;
            cursor: pointer;
            flex: 1 1 auto;
            min-width: 0;
            max-width: 100%;
            text-align: left;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .cloud-node-open:active {
            transform: translateY(1px);
        }
        .cloud-node-sub {
            color: rgba(219, 234, 255, 0.75);
            font-size: 0.79rem;
            line-height: 1.34;
            overflow-wrap: anywhere;
        }
        .cloud-node-actions {
            display: flex;
            flex-direction: column;
            align-items: stretch;
            gap: 0.3rem;
            flex: 0 0 auto;
            min-width: 0;
            max-width: 100%;
        }
        .cloud-node-action {
            border: 1px solid rgba(120, 171, 255, 0.42);
            background: rgba(28, 44, 80, 0.9);
            color: #edf6ff;
            border-radius: 8px;
            padding: 0.26rem 0.5rem;
            font-size: 0.76rem;
            font-weight: 700;
            cursor: pointer;
            min-width: 6.1rem;
            text-align: center;
            white-space: nowrap;
        }
        .cloud-node-action.danger {
            border-color: rgba(255, 126, 126, 0.45);
            background: rgba(86, 20, 20, 0.36);
            color: #ffd3d3;
        }
        .cloud-node-action:disabled {
            opacity: 0.56;
            cursor: default;
        }
        .cloud-status-note {
            font-size: 0.8rem;
            line-height: 1.34;
            color: rgba(212, 232, 255, 0.78);
            min-height: 1.08rem;
            overflow-wrap: anywhere;
            word-break: break-word;
        }
        .cloud-status-note.error {
            color: #ffd0d8;
        }
        .cloud-status-note.success {
            color: #bafcd7;
        }
        .cloud-preview-overlay {
            position: fixed;
            inset: 0;
            z-index: 1600;
            background: rgba(5, 10, 20, 0.82);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 1rem max(0.7rem, env(safe-area-inset-right, 0px))
                calc(1rem + var(--app-bottom-offset))
                max(0.7rem, env(safe-area-inset-left, 0px));
        }
        .cloud-preview-card {
            width: min(940px, 100%);
            border: 1px solid rgba(140, 189, 255, 0.24);
            border-radius: 14px;
            background: rgba(8, 14, 28, 0.98);
            box-shadow: 0 22px 56px rgba(0, 0, 0, 0.55);
            padding: 0.72rem;
            display: grid;
            gap: 0.62rem;
        }
        .cloud-preview-head {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 0.55rem;
        }
        .cloud-preview-title {
            color: #eef6ff;
            font-size: 0.9rem;
            line-height: 1.25;
            font-weight: 700;
            min-width: 0;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        .cloud-preview-media-wrap {
            width: 100%;
            min-height: 2.6rem;
            display: grid;
            place-items: center;
        }
        .cloud-preview-video {
            width: 100%;
            max-height: min(62vh, 520px);
            border-radius: 10px;
            background: #000;
        }
        .cloud-preview-audio {
            width: 100%;
        }
        .vless-guide-body {
            color: rgba(232, 243, 255, 0.9);
            font-size: 0.86rem;
            line-height: 1.42;
            white-space: pre-line;
            overflow-y: auto;
        }
        #vless-guide-card {
            min-height: min(82vh, 680px);
            grid-template-rows: auto 1fr auto;
        }
        .vless-guide-controls {
            display: grid;
            gap: 0.55rem;
            margin-top: 0.15rem;
        }
        .vless-guide-controls .work-btn {
            text-align: center;
        }
        .vless-guide-checkbox {
            display: inline-flex;
            align-items: center;
            gap: 0.45rem;
            color: rgba(225, 238, 255, 0.86);
            font-size: 0.82rem;
            line-height: 1.3;
            user-select: none;
        }
        .vless-guide-checkbox input {
            width: 1rem;
            height: 1rem;
            margin: 0;
            accent-color: #56b8ff;
        }
        .cloud-node-open.previewable {
            cursor: pointer;
        }
        @media (max-width: 420px) {
            .cloud-actions {
                grid-template-columns: 1fr;
            }
        }
        .work-empty {
            border: 1px dashed rgba(255, 255, 255, 0.15);
            border-radius: 12px;
            padding: 0.75rem;
            color: rgba(219, 234, 255, 0.72);
            font-size: 0.86rem;
        }
        .work-stub {
            min-height: 140px;
            display: flex;
            align-items: center;
        }

        h1 {
            margin: 0;
            font-size: clamp(1.75rem, 3vw, 2.25rem);
            line-height: 1.2;
        }

        p {
            margin: 0;
            line-height: 1.5;
            color: rgba(244, 245, 247, 0.85);
        }

        .app-content.hidden {
            display: none;
        }

        .status-card.hidden {
            display: none;
        }

        .hidden {
            display: none !important;
        }

        .pill {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 0.35rem 0.9rem;
            border-radius: 999px;
            font-size: 0.8rem;
            letter-spacing: 0.02em;
            text-transform: uppercase;
            color: #0a0f1a;
            background: linear-gradient(135deg, #facc15, #f97316);
            align-self: flex-start;
        }

        .cta {
            margin-top: 1.25rem;
            padding: 0.85rem 1.2rem;
            border-radius: 12px;
            border: none;
            font-size: 1rem;
            font-weight: 600;
            background: linear-gradient(135deg, #38bdf8, #6366f1);
            color: #fff;
            cursor: pointer;
            transition: transform 0.2s ease;
        }

        .cta:disabled {
            opacity: 0.5;
            cursor: wait;
        }

        .cta:not(:disabled):hover {
            transform: translateY(-1px);
        }

        /* === Breathing orb scene === */
        .pulse-scene {
            --glow-color: rgba(55, 224, 255, 0.55);
            --cycle: 4.8s; /* удлинили для тестов (было 2.4s) */
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1.1rem;
            width: 100%;
        }

        .orb-wrapper {
            position: relative;
            width: min(190px, 46vw);
            aspect-ratio: 1;
            transform-origin: 50% 50%;
        }

        .orb {
            position: absolute;
            inset: 0;
            border-radius: 50%;
            background:
                /* soft cyan base */
                radial-gradient(120% 120% at 22% 30%, rgba(80, 248, 255, 0.92), rgba(30, 38, 78, 0.0) 55%),
                /* deeper blue body */
                radial-gradient(110% 110% at 40% 55%, rgba(52, 129, 255, 0.85), rgba(12, 19, 40, 0.0) 70%),
                /* violet limb */
                radial-gradient(100% 100% at 78% 58%, rgba(158, 83, 255, 0.9), rgba(17, 16, 39, 0.0) 58%),
                /* subtle base tint */
                linear-gradient(135deg, #37e0ff 0%, #4f7bff 48%, #a855f7 100%);
            background-size: 150% 150%;
            animation:
                breathe var(--cycle) ease-in-out infinite,
                gradientShift 8s ease-in-out infinite alternate;
            box-shadow:
                0 0 28px 8px rgba(55, 224, 255, 0.18),
                0 0 64px 18px var(--glow-color),
                0 0 22px 6px rgba(148, 68, 255, 0.25);
            filter: drop-shadow(0 12px 28px rgba(0,0,0,0.35));
        }

        /* Crescent overlay for the 'slice' like in the icon */
        .orb::before {
            content: "";
            position: absolute;
            inset: -6%;
            border-radius: 50%;
            background: radial-gradient(85% 85% at 78% 42%, rgba(12, 17, 34, 0.78), rgba(12,17,34,0) 50%);
            mix-blend-mode: multiply;
            animation: breathe var(--cycle) ease-in-out infinite;
        }

        .orb::after {
            content: "";
            position: absolute;
            inset: -18%;
            border-radius: 50%;
            background: radial-gradient(circle, var(--glow-color) 0%, rgba(59, 123, 255, 0) 65%);
            filter: blur(18px);
            opacity: 0.7;
            animation: glowBreath var(--cycle) ease-in-out infinite;
        }

        .orb-highlight {
            position: absolute;
            inset: 14%;
            border-radius: 50%;
            background: radial-gradient(circle at 28% 28%, rgba(255,255,255,0.18), rgba(255,255,255,0));
            mix-blend-mode: screen;
            opacity: 0.12;
            animation: highlightBreath var(--cycle) ease-in-out infinite;
        }

        .status-label {
            font-size: 1.05rem;
            letter-spacing: 0.01em;
            color: rgba(244, 245, 247, 0.9);
            transition: opacity 150ms ease;
        }

        .status-label.fade-out {
            opacity: 0;
        }

        @keyframes breathe {
            0%   { transform: scale(1.00); }
            25%  { transform: scale(1.03); }
            50%  { transform: scale(1.06); }
            75%  { transform: scale(1.03); }
            100% { transform: scale(1.00); }
        }

        @keyframes glowBreath {
            0%   { opacity: 0.45; filter: blur(16px); }
            25%  { opacity: 0.58; filter: blur(18px); }
            50%  { opacity: 0.75; filter: blur(22px); }
            75%  { opacity: 0.62; filter: blur(18px); }
            100% { opacity: 0.45; filter: blur(16px); }
        }

        @keyframes highlightBreath {
            0%   { transform: scale(1.00); opacity: 0.10; }
            50%  { transform: scale(1.02); opacity: 0.15; }
            100% { transform: scale(1.00); opacity: 0.10; }
        }

        @keyframes gradientShift {
            0%   { background-position: 40% 40%; }
            100% { background-position: 60% 60%; }
        }

        /* Fullscreen loading stage */
        #loading {
            position: fixed;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background: linear-gradient(135deg, #0b1b45, #111b36 60%);
            z-index: 5;
        }

        /* Exit transition */
        #loading.exiting {
            animation: fadeOutBg 0.7s ease forwards;
        }

        .orb-wrapper.expand {
            animation: orbExpand 0.7s ease forwards;
        }

        @keyframes orbExpand {
            0% { transform: scale(1); opacity: 1; }
            70% { transform: scale(12); opacity: 0.35; }
            100% { transform: scale(18); opacity: 0; }
        }

        @keyframes fadeOutBg {
            to { opacity: 0; }
        }
    </style>
</head>
<body>
    <div id="loading">
        <div class="pulse-scene" id="pulse-scene">
            <div class="orb-wrapper">
                <div class="orb"></div>
                <div class="orb-highlight"></div>
            </div>
            <div class="status-label" id="status-label">Проверяем сервер…</div>
        </div>
    </div>

    <main class="hidden">
        <section id="status-card" class="status-card hidden">
            <h1 id="status-title">Доступ закрыт</h1>
            <p id="status-text">Попробуйте снова запустить мини‑приложение.</p>
        </section>

        <section id="app-content" class="app-content hidden">
            <div class="content">
            <div class="app-shell">
                <div class="topbar" id="topbar">
                    <div class="brand">Lumica Service</div>
                </div>

                <div class="hero-card" id="hero-card">
                    <div class="orb-hero">
                        <img class="hero-icon" alt="Lumica orb" src="data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 200 200'><defs><radialGradient id='g1' cx='30%' cy='30%' r='80%'><stop offset='0%' stop-color='%234ef0ff'/><stop offset='65%' stop-color='%232b5be0'/><stop offset='100%' stop-color='%231a1f3f' stop-opacity='0.05'/></radialGradient><radialGradient id='g2' cx='75%' cy='60%' r='55%'><stop offset='0%' stop-color='%23a060ff' stop-opacity='0.95'/><stop offset='100%' stop-color='%23101020' stop-opacity='0'/></radialGradient></defs><circle cx='100' cy='100' r='95' fill='url(%23g1)'/><circle cx='100' cy='100' r='95' fill='url(%23g2)'/><circle cx='120' cy='70' r='78' fill='rgba(10,15,40,0.45)'/></svg>" />
                    </div>
                    <div class="hero-caption" id="welcome-title">Lumica Service</div>
                    <div class="hero-sub" id="hero-sub">Сервер активен • Онлайн</div>
                </div>
                <div class="screen-menu-context hidden" id="screen-menu-context">
                    <div class="work-page-pill" id="screen-menu-context-pill" aria-live="polite"></div>
                </div>

                    <div id="screen-home" class="screen">
                        <div class="cards">
                            <div class="card">
                                <div class="left">
                                    <div class="badge">✓</div>
                                    <div>
                                        <div class="card-title">Сервер активен</div>
                                        <div class="card-sub" id="home-server-sub">Проверка...</div>
                                    </div>
                                </div>
                                <span class="chevron"></span>
                            </div>
                            <div class="card">
                                <div class="left">
                                    <div class="badge">◎</div>
                                    <div>
                                        <div class="card-title" id="home-sub-title">Подписка</div>
                                        <div class="card-sub" id="home-sub-sub">Проверка...</div>
                                    </div>
                                </div>
                                <span class="card-sub" id="home-sub-right">...</span>
                            </div>
                        </div>
                        <div class="home-main-actions">
                            <button type="button" class="card home-main-btn" data-screen="screen-connections">
                                <div class="left">
                                    <div class="badge">↧</div>
                                    <div>
                                        <div class="card-title">Подключения</div>
                                        <div class="card-sub">Открыть меню подключений</div>
                                    </div>
                                </div>
                                <span class="chevron">›</span>
                            </button>
                            <button type="button" class="card home-main-btn" id="home-cloud-btn" data-screen="screen-cloud">
                                <div class="left">
                                    <div class="badge">☁</div>
                                    <div>
                                        <div class="card-title">Облако</div>
                                        <div class="card-sub">Открыть файловое облако</div>
                                    </div>
                                </div>
                                <span class="chevron">›</span>
                            </button>
                        </div>
                    </div>

                    <div id="screen-connections" class="screen hidden">
                        <div class="work-page-context hidden" id="connections-page-context">
                            <div class="work-page-pill" id="connections-page-context-pill" aria-live="polite">Подключения</div>
                        </div>
                        <div class="connection-pages">
                            <section id="connections-menu-page">
                                <div class="cards">
                                    <button type="button" class="card connection-protocol-btn" id="vless-card" data-connection-protocol="vless">
                                        <div class="left">
                                            <div class="badge">V</div>
                                            <div>
                                                <div class="card-title">VLESS</div>
                                                <div class="card-sub" id="vless-status">Проверка...</div>
                                            </div>
                                        </div>
                                        <span class="chevron" id="vless-detail">›</span>
                                    </button>
                                    <button type="button" class="card connection-protocol-btn" id="http-card" data-connection-protocol="http">
                                        <div class="left">
                                            <div class="badge">H</div>
                                            <div>
                                                <div class="card-title">HTTP Proxy</div>
                                                <div class="card-sub" id="http-status">Проверка...</div>
                                            </div>
                                        </div>
                                        <span class="chevron" id="http-detail">›</span>
                                    </button>
                                    <button type="button" class="card connection-protocol-btn" id="mixed-card" data-connection-protocol="mixed">
                                        <div class="left">
                                            <div class="badge">M</div>
                                            <div>
                                                <div class="card-title">Mixed (SOCKS5)</div>
                                                <div class="card-sub" id="mixed-status">Проверка...</div>
                                            </div>
                                        </div>
                                        <span class="chevron" id="mixed-detail">›</span>
                                    </button>
                                    <div id="connections-hidden-note" class="work-empty hidden">Нет доступных подключений для показа в приложении.</div>
                                </div>
                            </section>

                            <section id="connections-detail-page" class="hidden">
                                <div class="work-page-head">
                                    <button type="button" class="work-back-btn" id="connections-back-btn">← Назад</button>
                                    <div class="work-page-title" id="connections-detail-title">Подключения</div>
                                </div>
                                <div class="connections-detail-info" id="connections-detail-subtitle">Информация о подключениях</div>
                                <div id="connections-detail-list" class="connections-detail-list">
                                    <div class="work-empty">Подключения не найдены.</div>
                                </div>
                            </section>
                        </div>
                    </div>

                    <div id="screen-work" class="screen hidden">
                        <div class="work-page-context hidden" id="work-page-context">
                            <div class="work-page-pill" id="work-page-context-pill" aria-live="polite">Работа</div>
                        </div>

                        <section id="work-menu-page" class="work-page">
                            <div class="work-profile-card" id="work-header-card">
                                <div class="work-profile-main">
                                    <div class="work-profile-avatar">👤</div>
                                    <div>
                                        <div class="work-profile-name" id="work-owner-name">Панель управления</div>
                                        <div class="work-profile-role" id="work-owner-role">user</div>
                                    </div>
                                </div>
                                <span class="pill-soft hidden" id="work-role-pill" aria-hidden="true"></span>
                            </div>

                            <div class="work-menu-groups">
                                <section class="work-menu-group">
                                    <div class="work-menu-group-title">Работа с людьми</div>
                                    <div class="work-menu-buttons">
                                        <button type="button" class="work-menu-btn" data-work-nav="work-staff-page">Персонал</button>
                                        <button type="button" class="work-menu-btn" data-work-nav="work-clients-page">Клиенты</button>
                                    </div>
                                </section>
                                <section class="work-menu-group">
                                    <div class="work-menu-group-title">Работа с подключениями</div>
                                    <div class="work-menu-buttons">
                                        <button type="button" class="work-menu-btn" data-work-nav="work-inbounds-page">Подключения</button>
                                        <button type="button" class="work-menu-btn" data-work-nav="work-system-settings-page">Системные настройки</button>
                                    </div>
                                </section>
                            </div>
                        </section>

                        <section id="work-staff-page" class="work-page hidden">
                            <div class="work-page-head">
                                <button class="work-back-btn" data-work-back="work-menu-page">← Назад</button>
                                <div class="work-page-title">Персонал</div>
                            </div>
                            <div class="work-empty work-stub">Экран персонала. Здесь можно разместить список сотрудников и роли.</div>
                        </section>

                        <section id="work-clients-page" class="work-page hidden">
                            <div class="work-page-head">
                                <button class="work-back-btn" data-work-back="work-menu-page">← Назад</button>
                                <div class="work-page-title">Клиенты</div>
                            </div>
                            <div id="work-client-cards" class="work-client-cards">
                                <div class="work-empty">Загрузка списка клиентов...</div>
                            </div>
                            <div class="work-actions">
                                <button type="button" class="work-action-link" data-work-nav="work-pending-page">
                                    <span class="work-action-link-label">Создание клиентов до входа</span>
                                    <span class="work-action-link-chevron" aria-hidden="true">›</span>
                                </button>
                            </div>
                        </section>

                        <section id="work-pending-page" class="work-page hidden">
                            <div class="work-page-head">
                                <button class="work-back-btn" data-work-back="work-clients-page">← Назад</button>
                                <div class="work-page-title">Создание клиентов до входа</div>
                            </div>
                            <div class="work-bind">
                                <label class="work-sub-create-label" for="work-pending-telegram-id">1. Telegram ID</label>
                                <input id="work-pending-telegram-id" type="text" inputmode="numeric" placeholder="Telegram ID">
                            </div>
                            <div class="work-page-title">2. Работа с подпиской</div>
                            <div class="work-bind">
                                <select id="work-pending-sub-status-select">
                                    <option value="active">active</option>
                                    <option value="lifetime">lifetime</option>
                                    <option value="paused">paused</option>
                                    <option value="expired">expired</option>
                                    <option value="canceled">canceled</option>
                                    <option value="inactive">inactive</option>
                                </select>
                                <input id="work-pending-sub-price-input" type="number" min="0" step="0.01" placeholder="Цена (₽)">
                                <input id="work-pending-sub-limit-input" type="number" min="0" step="1" placeholder="Лимит подключений">
                                <div id="work-pending-sub-create-wrap" class="work-sub-create-wrap">
                                    <label class="work-sub-create-label" for="work-pending-sub-create-date">Дата окончания</label>
                                    <input id="work-pending-sub-create-date" class="work-sub-create-input" type="date">
                                </div>
                                <button id="work-pending-sub-save-btn" class="work-btn">Сохранить подписку</button>
                                <div id="work-pending-sub-save-status" class="work-note">Укажи Telegram ID и сохрани параметры подписки.</div>
                            </div>
                            <div class="work-page-title">3. Добавить подключения</div>
                            <div class="work-bind">
                                <select id="work-pending-inbound-select">
                                    <option value="">Выбери inbound</option>
                                </select>
                                <select id="work-pending-client-select">
                                    <option value="">Выбери клиента из inbound</option>
                                </select>
                                <button id="work-pending-add-btn" class="work-btn">Добавить pending-привязку</button>
                                <div class="work-note">Этот inbound будет выдан автоматически при первом входе пользователя в приложение.</div>
                            </div>
                            <div id="work-pending-list" class="work-links-list">
                                <div class="work-empty">Pending-привязки пока нет.</div>
                            </div>
                        </section>

                        <section id="work-inbounds-page" class="work-page hidden">
                            <div class="work-page-head">
                                <button class="work-back-btn" data-work-back="work-menu-page">← Назад</button>
                                <div class="work-page-title">Подключения</div>
                            </div>
                            <div class="work-note">Нажми на подключение, чтобы развернуть его на весь экран и управлять видимостью.</div>
                            <div id="work-inbounds-list" class="work-inbounds-list">
                                <div class="work-empty">Загрузка подключений...</div>
                            </div>
                        </section>

                        <section id="work-inbound-detail-page" class="work-page hidden">
                            <div class="work-page-head">
                                <button class="work-back-btn" data-work-back="work-inbounds-page">← Назад</button>
                                <div id="work-inbound-detail-title" class="work-page-title">Подключение</div>
                            </div>
                            <div id="work-inbound-detail-meta" class="work-inbound-meta">—</div>
                            <div id="work-inbound-detail-badges" class="work-inbound-badges"></div>
                            <div class="work-inbound-detail-actions">
                                <button id="work-inbound-detail-toggle-btn" type="button" class="work-inbound-toggle-btn">
                                    Скрыть у пользователей
                                </button>
                            </div>
                            <div id="work-inbound-detail-note" class="work-note">Выбери подключение в списке.</div>
                        </section>

                        <section id="work-system-settings-page" class="work-page hidden">
                            <div class="work-page-head">
                                <button class="work-back-btn" data-work-back="work-menu-page">← Назад</button>
                                <div class="work-page-title">Системные настройки</div>
                                <button id="work-settings-refresh-btn" class="work-back-btn">Обновить</button>
                            </div>
                            <div class="work-note">Настройки применяются без перезапуска.</div>
                            <div class="work-bind">
                                <label class="work-sub-create-label" for="work-setting-cloud-visibility">cloud.visibility</label>
                                <select id="work-setting-cloud-visibility">
                                    <option value="true">true</option>
                                    <option value="false">false</option>
                                </select>

                                <label class="work-sub-create-label" for="work-setting-cloud-chunk-mb">cloud.upload.chunk_size_mb</label>
                                <input id="work-setting-cloud-chunk-mb" type="number" min="1" max="20" step="1" placeholder="1-20">

                                <label class="work-sub-create-label" for="work-setting-cloud-send-timeout">cloud.telegram.send.timeout_sec</label>
                                <input id="work-setting-cloud-send-timeout" type="number" min="30" max="1800" step="1" placeholder="30-1800">

                                <label class="work-sub-create-label" for="work-setting-cloud-send-retries">cloud.telegram.send.retries</label>
                                <input id="work-setting-cloud-send-retries" type="number" min="1" max="10" step="1" placeholder="1-10">

                                <label class="work-sub-create-label" for="work-setting-cloud-send-retry-delay">cloud.telegram.send.retry_delay_sec</label>
                                <input id="work-setting-cloud-send-retry-delay" type="number" min="1" max="60" step="1" placeholder="1-60">

                                <button id="work-settings-save-btn" class="work-btn">Сохранить настройки</button>
                                <div id="work-settings-save-status" class="work-note hidden"></div>
                            </div>
                        </section>

                        <section id="work-client-page" class="work-page hidden">
                            <div class="work-page-head">
                                <button class="work-back-btn" data-work-back="work-clients-page">← Назад</button>
                                <div class="work-page-title" id="work-client-page-title">Клиент</div>
                            </div>
                            <div class="card">
                                <div class="left">
                                    <div class="badge">👤</div>
                                    <div>
                                        <div class="card-title" id="work-client-name">—</div>
                                        <div class="card-sub" id="work-client-meta">—</div>
                                    </div>
                                </div>
                            </div>
                            <div class="card work-client-summary-card">
                                <div class="work-client-summary" id="work-client-summary">
                                    <div class="work-client-summary-row">
                                        <div class="work-client-summary-label">Подписка</div>
                                        <div class="work-client-summary-value" id="work-client-sub-status">—</div>
                                    </div>
                                    <div class="work-client-summary-row">
                                        <div class="work-client-summary-label">До</div>
                                        <div class="work-client-summary-value" id="work-client-sub-until">—</div>
                                    </div>
                                    <div class="work-client-summary-row">
                                        <div class="work-client-summary-label">Платит</div>
                                        <div class="work-client-summary-value" id="work-client-sub-price">—</div>
                                    </div>
                                    <div class="work-client-summary-row">
                                        <div class="work-client-summary-label">Лимит подключений</div>
                                        <div class="work-client-summary-value" id="work-client-connections-available">—</div>
                                    </div>
                                </div>
                            </div>
                            <div class="work-actions">
                                <button type="button" class="work-action-link" data-work-nav="work-client-connections-page">
                                    <span class="work-action-link-label">Подключения</span>
                                    <span class="work-action-link-chevron" aria-hidden="true">›</span>
                                </button>
                                <button type="button" class="work-action-link" data-work-nav="work-client-subscription-page">
                                    <span class="work-action-link-label">Подписка</span>
                                    <span class="work-action-link-chevron" aria-hidden="true">›</span>
                                </button>
                            </div>
                        </section>

                        <section id="work-client-connections-page" class="work-page hidden">
                            <div class="work-page-head">
                                <button class="work-back-btn" data-work-back="work-client-page">← Назад</button>
                                <div class="work-page-title">Подключения</div>
                            </div>
                            <div class="work-bind">
                                <select id="work-inbound-select">
                                    <option value="">Выбери inbound</option>
                                </select>
                                <select id="work-client-select">
                                    <option value="">Выбери клиента из inbound</option>
                                </select>
                                <div class="work-bind-actions">
                                    <button id="work-bind-btn" class="work-btn">Привязать inbound</button>
                                    <button id="work-refresh-inbound-clients-btn" type="button" class="work-btn">Обновить</button>
                                </div>
                                <div class="work-note">Порядок: пользователь → inbound → клиент → привязка.</div>
                            </div>
                            <div class="work-page-title">Существующие связи</div>
                            <div id="work-existing-links" class="work-links-list">
                                <div class="work-empty">Связи еще не загружены.</div>
                            </div>
                        </section>

                        <section id="work-client-subscription-page" class="work-page hidden">
                            <div class="work-page-head">
                                <button class="work-back-btn" data-work-back="work-client-page">← Назад</button>
                                <div class="work-page-title">Подписка</div>
                            </div>
                            <div class="work-bind">
                                <select id="work-sub-status-select">
                                    <option value="active">active</option>
                                    <option value="lifetime">lifetime</option>
                                    <option value="paused">paused</option>
                                    <option value="expired">expired</option>
                                    <option value="canceled">canceled</option>
                                    <option value="inactive">inactive</option>
                                </select>
                                <input id="work-sub-price-input" type="number" min="0" step="0.01" placeholder="Цена (₽)">
                                <input id="work-sub-limit-input" type="number" min="0" step="1" placeholder="Лимит подключений">
                                <button id="work-sub-save-btn" class="work-btn">Сохранить параметры</button>
                            </div>
                            <div class="work-bind">
                                <div id="work-sub-extend-wrap" class="work-sub-extend-wrap">
                                    <div class="work-sub-extend-head">
                                        <span class="work-sub-extend-label">Срок продления</span>
                                        <span class="work-sub-extend-value" id="work-sub-extend-value">1 месяц</span>
                                    </div>
                                    <input id="work-sub-extend-range" class="work-sub-extend-range" type="range" min="1" max="12" step="1" value="1">
                                </div>
                                <div id="work-sub-create-wrap" class="work-sub-create-wrap hidden">
                                    <label class="work-sub-create-label" for="work-sub-create-date">Дата окончания (если подписки нет)</label>
                                    <input id="work-sub-create-date" class="work-sub-create-input" type="date">
                                </div>
                                <button id="work-sub-extend-btn" class="work-btn">Продлить подписку</button>
                            </div>
                        </section>
                    </div>
                    <div id="screen-cloud" class="screen hidden">
                        <div class="work-page-context hidden" id="cloud-page-context">
                            <div class="work-page-pill" id="cloud-page-context-pill" aria-live="polite">Облако</div>
                        </div>
                        <section class="work-page cloud-page">
                            <div class="cloud-toolbar">
                                <button id="cloud-up-btn" type="button" class="work-back-btn hidden">← Назад</button>
                            </div>
                            <div class="cloud-path" id="cloud-path">/</div>
                            <div class="cloud-actions">
                                <button id="cloud-new-folder-btn" type="button" class="work-btn">Новая папка</button>
                                <label id="cloud-upload-label" class="work-btn cloud-upload-btn" for="cloud-upload-input">Загрузить файл</label>
                                <input id="cloud-upload-input" type="file" class="hidden" multiple>
                            </div>
                            <div id="cloud-upload-progress" class="cloud-upload-progress hidden" role="progressbar" aria-valuemin="0" aria-valuemax="100" aria-valuenow="0">
                                <div id="cloud-upload-progress-bar" class="cloud-upload-progress-bar"></div>
                            </div>
                            <div id="cloud-upload-progress-text" class="cloud-upload-progress-text hidden">0%</div>
                            <div id="cloud-status-note" class="cloud-status-note hidden"></div>
                            <div id="cloud-list" class="cloud-list">
                                <div class="work-empty">Откройте облако для загрузки списка.</div>
                            </div>
                        </section>
                        <div id="cloud-preview-overlay" class="cloud-preview-overlay hidden" aria-hidden="true">
                            <div id="cloud-preview-card" class="cloud-preview-card" role="dialog" aria-modal="true" aria-label="Предпросмотр медиафайла">
                                <div class="cloud-preview-head">
                                    <div id="cloud-preview-title" class="cloud-preview-title">Предпросмотр</div>
                                    <button id="cloud-preview-close-btn" type="button" class="work-back-btn">Закрыть</button>
                                </div>
                                <div id="cloud-preview-media-wrap" class="cloud-preview-media-wrap"></div>
                                <div id="cloud-preview-note" class="cloud-status-note hidden"></div>
                            </div>
                        </div>
                        <div id="vless-guide-overlay" class="cloud-preview-overlay hidden" aria-hidden="true">
                            <div id="vless-guide-card" class="cloud-preview-card" role="dialog" aria-modal="true" aria-label="Краткий гайд по VLESS">
                                <div class="cloud-preview-head">
                                    <div class="cloud-preview-title">Гайд по подключению VLESS</div>
                                </div>
                                <div id="vless-guide-text" class="vless-guide-body"></div>
                                <div class="vless-guide-controls">
                                    <label class="vless-guide-checkbox" for="vless-guide-hide-checkbox">
                                        <input id="vless-guide-hide-checkbox" type="checkbox">
                                        <span>Не показывать больше</span>
                                    </label>
                                    <button id="vless-guide-hide-btn" type="button" class="work-btn">Скрыть</button>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div id="screen-profile" class="screen hidden">
                        <div class="card">
                            <div class="left">
                                <div class="badge">ID</div>
                                <div>
                                    <div class="card-title">Ваш ID</div>
                                    <div class="card-sub" id="profile-telegram-id">••••</div>
                                </div>
                            </div>
                            <div class="pill-soft" id="profile-id-toggle">Скрыт</div>
                        </div>

                        <div class="card">
                            <div class="left">
                                <div class="badge">✓</div>
                                <div>
                                    <div class="card-title" id="profile-sub-title">Подписка</div>
                                    <div class="card-sub" id="profile-sub-sub">Проверка...</div>
                                </div>
                            </div>
                            <div class="pill-soft" id="profile-role">user</div>
                        </div>
                        <button type="button" class="card home-main-btn" data-screen="screen-settings">
                            <div class="left">
                                <div class="badge">⚙</div>
                                <div>
                                    <div class="card-title">Настройки</div>
                                    <div class="card-sub">Параметры интерфейса</div>
                                </div>
                            </div>
                            <span class="chevron">›</span>
                        </button>

                        <div class="card support-card">
                            <div class="card-title">Поддержка</div>
                            <div class="card-sub">Задайте вопрос в чате</div>
                        </div>
                    </div>
                    <div id="screen-settings" class="screen hidden">
                        <div class="card">
                            <div class="left">
                                <div class="badge">⚙️</div>
                                <div>
                                    <div class="card-title">Нижнее меню</div>
                                    <div class="card-sub">Второй пункт</div>
                                </div>
                            </div>
                            <select id="settings-nav-second-select" class="profile-nav-select">
                                <option value="connections">Подключения</option>
                                <option value="cloud">Облако</option>
                            </select>
                        </div>
                    </div>

                <nav class="bottom-nav">
                    <button class="nav-btn active" data-screen="screen-home">
                        <span class="icon">🏠</span>
                        <span>Главная</span>
                    </button>
                    <button class="nav-btn" id="nav-second-btn" data-screen="screen-connections">
                        <span class="icon" id="nav-second-icon">&#x2B07;&#xFE0F;</span>
                        <span id="nav-second-label">Подключения</span>
                    </button>
                    <button class="nav-btn hidden" id="nav-work-btn" data-screen="screen-work">
                        <span class="icon">🛠</span>
                        <span>Работа</span>
                    </button>
                    <button class="nav-btn" data-screen="screen-profile">
                        <span class="icon">👤</span>
                        <span>Профиль</span>
                    </button>
                </nav>
            </div>
            </div>
        </section>
    </main>

    <script>
        const statusCard = document.getElementById("status-card");
        const statusTitle = document.getElementById("status-title");
        const statusText = document.getElementById("status-text");
        const appContent = document.getElementById("app-content");
        const welcomeTitle = document.getElementById("welcome-title");
        const statusLabel = document.getElementById("status-label");
        const pulseScene = document.getElementById("pulse-scene");
        const loading = document.getElementById("loading");
        const mainEl = document.querySelector("main");
        const orbWrapper = document.querySelector(".orb-wrapper");
        const wait = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
        const navButtons = document.querySelectorAll("[data-screen]");
        const screens = document.querySelectorAll(".screen");
        const heroCardEl = document.getElementById("hero-card");
        const topbarEl = document.getElementById("topbar");
        const workSectionTitleEl = document.getElementById("work-section-title");
        const connectionsPageContextEl = document.getElementById("connections-page-context");
        const connectionsPageContextPillEl = document.getElementById("connections-page-context-pill");
        const workPageContextEl = document.getElementById("work-page-context");
        const workPageContextPillEl = document.getElementById("work-page-context-pill");
        const cloudPageContextEl = document.getElementById("cloud-page-context");
        const cloudPageContextPillEl = document.getElementById("cloud-page-context-pill");
        const screenMenuContextEl = document.getElementById("screen-menu-context");
        const screenMenuContextPillEl = document.getElementById("screen-menu-context-pill");
        const bottomNavEl = document.querySelector(".bottom-nav");
        const navSecondBtnEl = document.getElementById("nav-second-btn");
        const navSecondIconEl = document.getElementById("nav-second-icon");
        const navSecondLabelEl = document.getElementById("nav-second-label");
        const navWorkBtn = document.getElementById("nav-work-btn");
        const workPages = document.querySelectorAll("#screen-work .work-page");
        const workNavButtons = document.querySelectorAll("[data-work-nav]");
        const workBackButtons = document.querySelectorAll("[data-work-back]");
        const authUrl = `${window.location.origin}/api/tg/auth`;
        const meUrl = `${window.location.origin}/api/me`;
        const statusUrl = `${window.location.origin}/api/status`;
        const vpnConfigUrl = `${window.location.origin}/api/vpn/config`;
        const vpnHttpUrl = `${window.location.origin}/api/vpn/http`;
        const vpnMixedUrl = `${window.location.origin}/api/vpn/mixed`;
        const adminUsersUrl = `${window.location.origin}/api/admin/users`;
        const adminInboundsUrl = `${window.location.origin}/api/admin/inbounds`;
        const adminSyncInboundsUrl = `${window.location.origin}/api/admin/sync-inbounds`;
        const adminBindClientUrl = `${window.location.origin}/api/admin/bind-client`;
        const adminUnbindClientUrl = `${window.location.origin}/api/admin/unbind-client`;
        const adminPendingBindingsUrl = `${window.location.origin}/api/admin/pending-bindings`;
        const adminCancelPendingBindingUrl = (pendingId) =>
            `${window.location.origin}/api/admin/pending-bindings/${pendingId}/cancel`;
        const adminInboundVisibilityUrl = (panelInboundId) => `${window.location.origin}/api/admin/inbounds/${panelInboundId}/visibility`;
        const adminUserBindingsUrl = (userId) => `${window.location.origin}/api/admin/users/${userId}/bindings`;
        const adminUserOverviewUrl = (userId) => `${window.location.origin}/api/admin/users/${userId}/overview`;
        const adminUserSubscriptionUrl = (userId) => `${window.location.origin}/api/admin/users/${userId}/subscription`;
        const adminUserOverviewByTelegramUrl = (telegramId) =>
            `${window.location.origin}/api/admin/users/by-telegram/${encodeURIComponent(telegramId)}/overview`;
        const adminUserSubscriptionByTelegramUrl = `${window.location.origin}/api/admin/users/by-telegram/subscription`;
        const adminSettingsUrl = `${window.location.origin}/api/admin/settings`;
        const adminSettingUrl = (settingKey) => `${adminSettingsUrl}/${encodeURIComponent(settingKey)}`;
        const cloudListUrl = `${window.location.origin}/api/cloud/list`;
        const cloudMkdirUrl = `${window.location.origin}/api/cloud/mkdir`;
        const cloudUploadUrl = `${window.location.origin}/api/cloud/upload`;
        const cloudDeleteNodeUrl = (nodeId) => `${window.location.origin}/api/cloud/nodes/${nodeId}`;
        const cloudDownloadFileUrl = (fileId) => `${window.location.origin}/api/cloud/files/${fileId}/download`;
        const homeServerSub = document.getElementById("home-server-sub");
        const homeSubTitle = document.getElementById("home-sub-title");
        const homeSubSub = document.getElementById("home-sub-sub");
        const homeSubRight = document.getElementById("home-sub-right");
        const homeCloudBtnEl = document.getElementById("home-cloud-btn");
        const settingsNavSecondSelectEl = document.getElementById("settings-nav-second-select");
        const connectionsMenuPageEl = document.getElementById("connections-menu-page");
        const connectionsDetailPageEl = document.getElementById("connections-detail-page");
        const connectionsBackBtnEl = document.getElementById("connections-back-btn");
        const connectionsDetailTitleEl = document.getElementById("connections-detail-title");
        const connectionsDetailSubtitleEl = document.getElementById("connections-detail-subtitle");
        const connectionsDetailListEl = document.getElementById("connections-detail-list");
        const connectionProtocolButtons = document.querySelectorAll("[data-connection-protocol]");
        const vlessCardEl = document.getElementById("vless-card");
        const httpCardEl = document.getElementById("http-card");
        const mixedCardEl = document.getElementById("mixed-card");
        const connectionsHiddenNoteEl = document.getElementById("connections-hidden-note");
        const vlessStatusEl = document.getElementById("vless-status");
        const vlessDetailEl = document.getElementById("vless-detail");
        const httpStatusEl = document.getElementById("http-status");
        const httpDetailEl = document.getElementById("http-detail");
        const mixedStatusEl = document.getElementById("mixed-status");
        const mixedDetailEl = document.getElementById("mixed-detail");
        const profileTelegramIdEl = document.getElementById("profile-telegram-id");
        const profileIdToggleEl = document.getElementById("profile-id-toggle");
        const profileSubTitleEl = document.getElementById("profile-sub-title");
        const profileSubSubEl = document.getElementById("profile-sub-sub");
        const profileRoleEl = document.getElementById("profile-role");
        const workOwnerNameEl = document.getElementById("work-owner-name");
        const workOwnerRoleEl = document.getElementById("work-owner-role");
        const workRolePillEl = document.getElementById("work-role-pill");
        const workSettingsRefreshBtnEl = document.getElementById("work-settings-refresh-btn");
        const workSettingsSaveBtnEl = document.getElementById("work-settings-save-btn");
        const workSettingsSaveStatusEl = document.getElementById("work-settings-save-status");
        const workSettingCloudVisibilityEl = document.getElementById("work-setting-cloud-visibility");
        const workSettingCloudChunkMbEl = document.getElementById("work-setting-cloud-chunk-mb");
        const workSettingCloudSendTimeoutEl = document.getElementById("work-setting-cloud-send-timeout");
        const workSettingCloudSendRetriesEl = document.getElementById("work-setting-cloud-send-retries");
        const workSettingCloudSendRetryDelayEl = document.getElementById("work-setting-cloud-send-retry-delay");
        const workInboundsListEl = document.getElementById("work-inbounds-list");
        const workInboundDetailTitleEl = document.getElementById("work-inbound-detail-title");
        const workInboundDetailMetaEl = document.getElementById("work-inbound-detail-meta");
        const workInboundDetailBadgesEl = document.getElementById("work-inbound-detail-badges");
        const workInboundDetailToggleBtnEl = document.getElementById("work-inbound-detail-toggle-btn");
        const workInboundDetailNoteEl = document.getElementById("work-inbound-detail-note");
        const workClientCardsEl = document.getElementById("work-client-cards");
        const workClientPageTitleEl = document.getElementById("work-client-page-title");
        const workClientNameEl = document.getElementById("work-client-name");
        const workClientMetaEl = document.getElementById("work-client-meta");
        const workClientSubStatusEl = document.getElementById("work-client-sub-status");
        const workClientSubUntilEl = document.getElementById("work-client-sub-until");
        const workClientSubPriceEl = document.getElementById("work-client-sub-price");
        const workClientConnectionsAvailableEl = document.getElementById("work-client-connections-available");
        const workExistingLinksEl = document.getElementById("work-existing-links");
        const workInboundSelectEl = document.getElementById("work-inbound-select");
        const workClientSelectEl = document.getElementById("work-client-select");
        const workBindBtnEl = document.getElementById("work-bind-btn");
        const workRefreshInboundClientsBtnEl = document.getElementById("work-refresh-inbound-clients-btn");
        const workPendingTelegramIdEl = document.getElementById("work-pending-telegram-id");
        const workPendingInboundSelectEl = document.getElementById("work-pending-inbound-select");
        const workPendingClientSelectEl = document.getElementById("work-pending-client-select");
        const workPendingAddBtnEl = document.getElementById("work-pending-add-btn");
        const workPendingListEl = document.getElementById("work-pending-list");
        const workPendingSubStatusSelectEl = document.getElementById("work-pending-sub-status-select");
        const workPendingSubPriceInputEl = document.getElementById("work-pending-sub-price-input");
        const workPendingSubLimitInputEl = document.getElementById("work-pending-sub-limit-input");
        const workPendingSubCreateWrapEl = document.getElementById("work-pending-sub-create-wrap");
        const workPendingSubCreateDateEl = document.getElementById("work-pending-sub-create-date");
        const workPendingSubSaveBtnEl = document.getElementById("work-pending-sub-save-btn");
        const workPendingSubSaveStatusEl = document.getElementById("work-pending-sub-save-status");
        const workSubStatusSelectEl = document.getElementById("work-sub-status-select");
        const workSubPriceInputEl = document.getElementById("work-sub-price-input");
        const workSubLimitInputEl = document.getElementById("work-sub-limit-input");
        const workSubSaveBtnEl = document.getElementById("work-sub-save-btn");
        const workSubExtendWrapEl = document.getElementById("work-sub-extend-wrap");
        const workSubCreateWrapEl = document.getElementById("work-sub-create-wrap");
        const workSubCreateDateEl = document.getElementById("work-sub-create-date");
        const workSubExtendRangeEl = document.getElementById("work-sub-extend-range");
        const workSubExtendValueEl = document.getElementById("work-sub-extend-value");
        const workSubExtendBtnEl = document.getElementById("work-sub-extend-btn");
        const cloudUpBtnEl = document.getElementById("cloud-up-btn");
        const cloudNewFolderBtnEl = document.getElementById("cloud-new-folder-btn");
        const cloudUploadInputEl = document.getElementById("cloud-upload-input");
        const cloudUploadLabelEl = document.getElementById("cloud-upload-label");
        const cloudUploadProgressEl = document.getElementById("cloud-upload-progress");
        const cloudUploadProgressBarEl = document.getElementById("cloud-upload-progress-bar");
        const cloudUploadProgressTextEl = document.getElementById("cloud-upload-progress-text");
        const cloudPathEl = document.getElementById("cloud-path");
        const cloudStatusNoteEl = document.getElementById("cloud-status-note");
        const cloudListEl = document.getElementById("cloud-list");
        const cloudPreviewOverlayEl = document.getElementById("cloud-preview-overlay");
        const cloudPreviewCardEl = document.getElementById("cloud-preview-card");
        const cloudPreviewTitleEl = document.getElementById("cloud-preview-title");
        const cloudPreviewCloseBtnEl = document.getElementById("cloud-preview-close-btn");
        const cloudPreviewMediaWrapEl = document.getElementById("cloud-preview-media-wrap");
        const cloudPreviewNoteEl = document.getElementById("cloud-preview-note");
        const vlessGuideOverlayEl = document.getElementById("vless-guide-overlay");
        const vlessGuideCardEl = document.getElementById("vless-guide-card");
        const vlessGuideHideBtnEl = document.getElementById("vless-guide-hide-btn");
        const vlessGuideHideCheckboxEl = document.getElementById("vless-guide-hide-checkbox");
        const vlessGuideTextEl = document.getElementById("vless-guide-text");
        const systemSettingKeys = {
            cloudVisibility: "cloud.visibility",
            cloudChunkSizeMb: "cloud.upload.chunk_size_mb",
            cloudSendTimeoutSec: "cloud.telegram.send.timeout_sec",
            cloudSendRetries: "cloud.telegram.send.retries",
            cloudSendRetryDelaySec: "cloud.telegram.send.retry_delay_sec",
        };
        const workState = {
            users: [],
            inbounds: [],
            clients: [],
            bindings: [],
            pendingClients: [],
            pendingBindings: [],
            pendingOverview: null,
            settings: {},
            selectedUserId: null,
            overview: null,
            selectedInboundPanelId: null,
        };
        const FORCE_HIDE_TOPBAR = true;
        const FULLSCREEN_TOP_RESERVE_PX = 28;
        const FULLSCREEN_BOTTOM_RESERVE_PX = 2;
        const connectionsState = {
            activeProtocol: null,
            entries: {
                vless: [],
                http: [],
                mixed: [],
            },
            visibility: {
                vless: false,
                http: false,
                mixed: false,
            },
        };
        const cloudState = {
            path: "/",
            folders: [],
            files: [],
            initialized: false,
            isUploading: false,
        };
        const uiFeatures = {
            cloudEnabled: true,
        };
        const NAV_SECOND_ITEM_KEY = "nav_second_item";
        const VLESS_GUIDE_HIDE_KEY = "vless_guide_hide";
        const navSecondButtonByKey = {
            connections: {
                key: "connections",
                screen: "screen-connections",
                icon: "⬇️",
                label: "Подключения",
            },
            cloud: {
                key: "cloud",
                screen: "screen-cloud",
                icon: "☁️",
                label: "Облако",
            },
        };
        const navPreference = {
            secondItem: "connections",
        };
        const vlessGuidePreference = {
            dontShow: false,
            loaded: false,
        };
        let lastUserPayload = null;
        let csrfToken = "";
        let showFullTelegramId = false;
        let viewportListenerBound = false;
        let tgBackButtonBound = false;
        let screenMenuActionBusy = false;
        let screenMenuActionCurrent = "";
        let workPageActionBusy = false;
        let workPageActionCurrent = "";
        const workBackTargetByPage = new Map();
        workBackButtons.forEach((btn) => {
            const pageId = btn.closest(".work-page")?.id;
            if (!pageId) return;
            workBackTargetByPage.set(pageId, btn.dataset.workBack || "work-menu-page");
        });
        const workContextTitleByPage = new Map([
            ["work-staff-page", "Персонал"],
            ["work-clients-page", "Клиенты"],
            ["work-pending-page", "Создание клиентов до входа"],
            ["work-inbounds-page", "Подключения"],
            ["work-system-settings-page", "Системные настройки"],
            ["work-client-page", "Клиент"],
            ["work-client-connections-page", "Подключения"],
            ["work-client-subscription-page", "Подписка"],
        ]);
        const menuContextTitleByScreen = new Map([
            ["screen-connections", "Подключения"],
            ["screen-cloud", "Облако"],
            ["screen-work", "Работа"],
            ["screen-profile", "Профиль"],
            ["screen-settings", "Настройки"],
        ]);
        const cloudAudioExtensions = new Set(["mp3", "m4a", "aac", "ogg", "opus", "wav", "flac", "alac", "wma", "amr", "mid", "midi"]);
        const cloudVideoExtensions = new Set(["mp4", "m4v", "mov", "mkv", "webm", "avi", "wmv", "flv", "mpeg", "mpg", "3gp", "ts"]);
        const cloudImageExtensions = new Set(["jpg", "jpeg", "png", "gif", "webp", "bmp", "tiff", "tif", "svg", "heic", "heif", "ico", "avif"]);
        const cloudArchiveExtensions = new Set(["zip", "rar", "7z", "tar", "gz", "bz2", "xz", "tgz", "tbz", "txz", "zst"]);
        const cloudDocumentExtensions = new Set(["doc", "docx", "odt", "pages"]);
        const cloudSheetExtensions = new Set(["xls", "xlsx", "ods", "csv", "tsv", "numbers"]);
        const cloudSlideExtensions = new Set(["ppt", "pptx", "odp", "key"]);
        const cloudCodeExtensions = new Set([
            "py",
            "js",
            "ts",
            "jsx",
            "tsx",
            "html",
            "htm",
            "css",
            "scss",
            "sass",
            "less",
            "json",
            "xml",
            "yaml",
            "yml",
            "toml",
            "ini",
            "cfg",
            "env",
            "sh",
            "bat",
            "ps1",
            "sql",
            "go",
            "rs",
            "java",
            "kt",
            "c",
            "h",
            "cpp",
            "hpp",
            "cs",
            "php",
            "rb",
            "swift",
            "dart",
            "lua",
        ]);

        function isMobileTelegramPlatform(tg) {
            const platform = String(tg?.platform || "").toLowerCase();
            return platform === "android" || platform === "ios";
        }

        function updateSafeAreaVars(tg) {
            const safeArea = tg?.safeAreaInset || tg?.contentSafeAreaInset;
            const top = Number(safeArea?.top) || 0;
            const bottom = Number(safeArea?.bottom) || 0;
            document.documentElement.style.setProperty("--safe-top", `${top}px`);
            document.documentElement.style.setProperty("--safe-bottom", `${bottom}px`);
        }

        function applyTopReserve(enabled) {
            const reserve = enabled ? FULLSCREEN_TOP_RESERVE_PX : 0;
            document.documentElement.style.setProperty("--system-top-reserve", `${reserve}px`);
        }

        function applyBottomReserve(enabled) {
            const reserve = enabled ? FULLSCREEN_BOTTOM_RESERVE_PX : 0;
            document.documentElement.style.setProperty("--system-nav-reserve", `${reserve}px`);
        }

        function ensureSafeViewportMode() {
            const tg = window.Telegram?.WebApp;
            if (!tg) {
                applyTopReserve(false);
                applyBottomReserve(false);
                return;
            }
            try {
                const isMobile = isMobileTelegramPlatform(tg);
                const canFullscreen = isMobile && typeof tg.requestFullscreen === "function" && tg.isVersionAtLeast?.("8.0");
                updateSafeAreaVars(tg);
                tg.expand?.();
                if (canFullscreen) {
                    try {
                        tg.requestFullscreen();
                    } catch (fullscreenErr) {
                        console.warn("requestFullscreen failed:", fullscreenErr);
                    }
                }
                applyTopReserve(Boolean(tg.isFullscreen) || canFullscreen);
                applyBottomReserve(Boolean(tg.isFullscreen) || canFullscreen);

                if (!viewportListenerBound && typeof tg.onEvent === "function") {
                    tg.onEvent("viewportChanged", () => {
                        updateSafeAreaVars(tg);
                        applyTopReserve(Boolean(tg.isFullscreen) || canFullscreen);
                        applyBottomReserve(Boolean(tg.isFullscreen) || canFullscreen);
                    });
                    viewportListenerBound = true;
                }
            } catch (err) {
                console.error("viewport mode setup error:", err);
            }
        }

        function setTopbarVisibility(shouldHide = false) {
            if (!topbarEl) return;
            if (FORCE_HIDE_TOPBAR || shouldHide) {
                topbarEl.classList.add("hidden");
            } else {
                topbarEl.classList.remove("hidden");
            }
        }

        function getActiveScreenId() {
            const active = Array.from(screens).find((screen) => !screen.classList.contains("hidden"));
            return active?.id || "";
        }

        function getActiveWorkPageId() {
            const active = Array.from(workPages).find((page) => !page.classList.contains("hidden"));
            return active?.id || "";
        }

        function updateScreenMenuContext(screenId = getActiveScreenId()) {
            if (!screenMenuContextEl || !screenMenuContextPillEl) return;
            let title = "";
            let action = "";

            if (screenId === "screen-connections" && connectionsDetailPageEl?.classList.contains("hidden")) {
                title = menuContextTitleByScreen.get("screen-connections") || "";
                action = "refresh-connections";
            } else if (screenId === "screen-cloud") {
                title = menuContextTitleByScreen.get("screen-cloud") || "";
                action = "refresh-cloud";
            } else if (screenId === "screen-work" && getActiveWorkPageId() === "work-menu-page") {
                title = menuContextTitleByScreen.get("screen-work") || "";
            } else if (screenId === "screen-profile") {
                title = menuContextTitleByScreen.get("screen-profile") || "";
            } else if (screenId === "screen-settings") {
                title = menuContextTitleByScreen.get("screen-settings") || "";
            }

            if (!title) {
                screenMenuContextEl.dataset.action = "";
                screenMenuContextEl.classList.remove("clickable");
                screenMenuContextPillEl.tabIndex = -1;
                screenMenuContextPillEl.removeAttribute("role");
                screenMenuContextEl.classList.add("hidden");
                return;
            }

            const isBusyForAction = Boolean(action) && screenMenuActionBusy && action === screenMenuActionCurrent;
            const displayTitle = isBusyForAction
                ? `${title} ⏳`
                : action
                    ? `${title} 🔄`
                    : title;

            screenMenuContextEl.dataset.action = action || "";
            screenMenuContextEl.classList.toggle("clickable", Boolean(action) && !screenMenuActionBusy);
            screenMenuContextPillEl.tabIndex = Boolean(action) && !screenMenuActionBusy ? 0 : -1;
            if (action) {
                screenMenuContextPillEl.setAttribute("role", "button");
            } else {
                screenMenuContextPillEl.removeAttribute("role");
            }
            screenMenuContextPillEl.textContent = displayTitle;
            screenMenuContextPillEl.title = displayTitle;
            screenMenuContextEl.classList.remove("hidden");
        }

        async function runScreenMenuContextAction() {
            const action = String(screenMenuContextEl?.dataset?.action || "").trim();
            if (!action || screenMenuActionBusy) {
                return;
            }

            screenMenuActionBusy = true;
            screenMenuActionCurrent = action;
            updateScreenMenuContext(getActiveScreenId());

            try {
                if (action === "refresh-cloud") {
                    await ensureCloudLoaded(true);
                } else if (action === "refresh-connections") {
                    const runtime = await loadRuntimeData();
                    renderDashboard(runtime);
                }
            } catch (err) {
                console.error("screen menu action error:", err);
                if (action === "refresh-cloud") {
                    setCloudStatus(err?.message || "Не удалось обновить файлы", "error");
                }
            } finally {
                screenMenuActionBusy = false;
                screenMenuActionCurrent = "";
                updateScreenMenuContext(getActiveScreenId());
            }
        }

        function resolveWorkContextTitle(pageId) {
            if (pageId === "work-client-page") {
                const dynamicTitle = String(workClientPageTitleEl?.textContent || "").trim();
                return dynamicTitle || "Клиент";
            }
            return workContextTitleByPage.get(pageId) || "";
        }

        function resolveWorkContextAction(pageId) {
            if (pageId === "work-clients-page") {
                return "refresh-work-clients";
            }
            if (pageId === "work-inbounds-page") {
                return "sync-work-inbounds";
            }
            if (!workState.selectedUserId) {
                return "";
            }
            if (
                pageId === "work-client-page"
                || pageId === "work-client-connections-page"
                || pageId === "work-client-subscription-page"
            ) {
                return "refresh-work-client";
            }
            return "";
        }

        function updateWorkPageContext(pageId) {
            if (!workPageContextEl || !workPageContextPillEl) return;
            if (!pageId || pageId === "work-menu-page") {
                workPageContextEl.dataset.action = "";
                workPageContextEl.classList.remove("clickable");
                workPageContextPillEl.tabIndex = -1;
                workPageContextPillEl.removeAttribute("role");
                workPageContextEl.classList.add("hidden");
                return;
            }
            const title = resolveWorkContextTitle(pageId);
            if (!title) {
                workPageContextEl.dataset.action = "";
                workPageContextEl.classList.remove("clickable");
                workPageContextPillEl.tabIndex = -1;
                workPageContextPillEl.removeAttribute("role");
                workPageContextEl.classList.add("hidden");
                return;
            }
            const action = resolveWorkContextAction(pageId);
            const isBusyForAction = Boolean(action) && workPageActionBusy && action === workPageActionCurrent;
            const displayTitle = isBusyForAction
                ? `${title} ⟳`
                : action
                    ? `${title} 🔄`
                    : title;

            workPageContextEl.dataset.action = action || "";
            workPageContextEl.classList.toggle("clickable", Boolean(action) && !workPageActionBusy);
            workPageContextPillEl.tabIndex = Boolean(action) && !workPageActionBusy ? 0 : -1;
            if (action) {
                workPageContextPillEl.setAttribute("role", "button");
            } else {
                workPageContextPillEl.removeAttribute("role");
            }
            workPageContextPillEl.textContent = displayTitle;
            workPageContextPillEl.title = displayTitle;
            workPageContextEl.classList.remove("hidden");
        }

        async function runWorkPageContextAction() {
            const action = String(workPageContextEl?.dataset?.action || "").trim();
            if (!action || workPageActionBusy) {
                return;
            }

            workPageActionBusy = true;
            workPageActionCurrent = action;
            updateWorkPageContext(getActiveWorkPageId());

            try {
                if (action === "refresh-work-clients") {
                    await loadWorkClientsData();
                } else if (action === "sync-work-inbounds") {
                    await postJson(adminSyncInboundsUrl);
                    const inboundsResp = await fetchJson(adminInboundsUrl, false);
                    workState.inbounds = Array.isArray(inboundsResp?.inbounds) ? inboundsResp.inbounds : [];
                    renderWorkInboundsManager();
                    renderWorkInboundSelectOptions();
                    renderWorkPendingInboundSelectOptions();
                } else if (action === "refresh-work-client") {
                    const tasks = [
                        loadSelectedUserBindings(),
                        loadSelectedUserOverview(),
                    ];
                    if (workInboundSelectEl?.value) {
                        tasks.push(loadInboundClients(workInboundSelectEl.value));
                    }
                    const pendingTgId = workPendingTelegramIdEl?.value?.trim();
                    if (pendingTgId) {
                        tasks.push(loadPendingBindings(pendingTgId));
                        tasks.push(loadPendingSubscriptionOverview(pendingTgId));
                    }
                    await Promise.all(tasks);
                }
            } catch (err) {
                console.error("work page context action error:", err);
            } finally {
                workPageActionBusy = false;
                workPageActionCurrent = "";
                updateWorkPageContext(getActiveWorkPageId());
            }
        }

        function updateConnectionsPageContext(protocol) {
            if (!connectionsPageContextEl || !connectionsPageContextPillEl) return;
            if (!protocol) {
                connectionsPageContextEl.classList.add("hidden");
                return;
            }
            const title = connectionProtocolTitle(protocol);
            connectionsPageContextPillEl.textContent = title;
            connectionsPageContextPillEl.title = title;
            connectionsPageContextEl.classList.remove("hidden");
        }

        function cloudPathParts(path) {
            if (!path || path === "/") return [];
            return String(path)
                .split("/")
                .map((part) => part.trim())
                .filter(Boolean);
        }

        function normalizeCloudPath(rawPath) {
            const value = String(rawPath || "/").replace(/\\/g, "/").trim();
            if (!value || value === "/") return "/";
            const parts = value
                .split("/")
                .map((part) => part.trim())
                .filter((part) => part && part !== "." && part !== "..");
            return parts.length ? `/${parts.join("/")}` : "/";
        }

        function cloudParentPath(path) {
            const parts = cloudPathParts(path);
            if (!parts.length) return "/";
            parts.pop();
            return parts.length ? `/${parts.join("/")}` : "/";
        }

        function cloudContextTitle(path) {
            const parts = cloudPathParts(path);
            return parts.length ? parts[parts.length - 1] : "Облако";
        }

        function updateCloudPageContext(path) {
            if (!cloudPageContextEl) return;
            cloudPageContextEl.classList.add("hidden");
        }

        function normalizeNavSecondItemKey(rawValue) {
            const value = String(rawValue || "").trim().toLowerCase();
            return value === "cloud" ? "cloud" : "connections";
        }

        function getTelegramCloudStorageApi() {
            return window.Telegram?.WebApp?.CloudStorage || null;
        }

        function cloudStorageGetItem(key) {
            return new Promise((resolve, reject) => {
                const api = getTelegramCloudStorageApi();
                if (!api || typeof api.getItem !== "function") {
                    resolve(null);
                    return;
                }
                try {
                    api.getItem(String(key), (error, value) => {
                        if (error) {
                            reject(new Error(String(error)));
                            return;
                        }
                        resolve(value ?? null);
                    });
                } catch (err) {
                    reject(err);
                }
            });
        }

        function cloudStorageSetItem(key, value) {
            return new Promise((resolve, reject) => {
                const api = getTelegramCloudStorageApi();
                if (!api || typeof api.setItem !== "function") {
                    resolve(false);
                    return;
                }
                try {
                    api.setItem(String(key), String(value), (error) => {
                        if (error) {
                            reject(new Error(String(error)));
                            return;
                        }
                        resolve(true);
                    });
                } catch (err) {
                    reject(err);
                }
            });
        }

        function resolveEffectiveNavSecondItemKey() {
            const selected = normalizeNavSecondItemKey(navPreference.secondItem);
            if (selected === "cloud" && !uiFeatures.cloudEnabled) {
                return "connections";
            }
            return selected;
        }

        function applyNavSecondButtonConfig() {
            const effectiveKey = resolveEffectiveNavSecondItemKey();
            const config = navSecondButtonByKey[effectiveKey] || navSecondButtonByKey.connections;
            if (navSecondBtnEl) {
                navSecondBtnEl.dataset.screen = config.screen;
                navSecondBtnEl.title = config.label;
                navSecondBtnEl.classList.remove("hidden");
            }
            if (navSecondIconEl) {
                navSecondIconEl.textContent = config.icon;
            }
            if (navSecondLabelEl) {
                navSecondLabelEl.textContent = config.label;
            }
            if (settingsNavSecondSelectEl) {
                const cloudOption = settingsNavSecondSelectEl.querySelector('option[value="cloud"]');
                if (cloudOption) {
                    cloudOption.disabled = !uiFeatures.cloudEnabled;
                }
                settingsNavSecondSelectEl.value = normalizeNavSecondItemKey(navPreference.secondItem);
            }
            const activeScreenId = getActiveScreenId();
            navButtons.forEach((btn) => btn.classList.toggle("active", btn.dataset.screen === activeScreenId));
        }

        async function loadNavSecondPreference() {
            let storedValue = null;
            try {
                storedValue = window.localStorage?.getItem(NAV_SECOND_ITEM_KEY) || null;
            } catch (_err) {
                storedValue = null;
            }

            try {
                const cloudValue = await cloudStorageGetItem(NAV_SECOND_ITEM_KEY);
                if (typeof cloudValue === "string" && cloudValue.trim()) {
                    storedValue = cloudValue;
                }
            } catch (err) {
                console.warn("CloudStorage get nav_second_item failed:", err);
            }

            navPreference.secondItem = normalizeNavSecondItemKey(storedValue);
            applyNavSecondButtonConfig();
        }

        async function saveNavSecondPreference(nextValue) {
            const normalized = normalizeNavSecondItemKey(nextValue);
            navPreference.secondItem = normalized;
            applyNavSecondButtonConfig();
            try {
                window.localStorage?.setItem(NAV_SECOND_ITEM_KEY, normalized);
            } catch (_err) {
                // ignore localStorage failures
            }
            try {
                await cloudStorageSetItem(NAV_SECOND_ITEM_KEY, normalized);
            } catch (err) {
                console.warn("CloudStorage set nav_second_item failed:", err);
            }
        }

        function normalizeVlessGuideHideValue(rawValue) {
            const value = String(rawValue || "").trim().toLowerCase();
            return value === "1" || value === "true" || value === "yes" || value === "on";
        }

        function applyVlessGuidePreference(dontShow) {
            vlessGuidePreference.dontShow = Boolean(dontShow);
            if (vlessGuideHideCheckboxEl) {
                vlessGuideHideCheckboxEl.checked = vlessGuidePreference.dontShow;
            }
        }

        async function loadVlessGuidePreference() {
            if (vlessGuidePreference.loaded) {
                applyVlessGuidePreference(vlessGuidePreference.dontShow);
                return vlessGuidePreference.dontShow;
            }

            let storedValue = null;
            try {
                storedValue = window.localStorage?.getItem(VLESS_GUIDE_HIDE_KEY) || null;
            } catch (_err) {
                storedValue = null;
            }

            try {
                const cloudValue = await cloudStorageGetItem(VLESS_GUIDE_HIDE_KEY);
                if (typeof cloudValue === "string" && cloudValue.trim()) {
                    storedValue = cloudValue;
                }
            } catch (err) {
                console.warn("CloudStorage get vless_guide_hide failed:", err);
            }

            const resolvedValue = normalizeVlessGuideHideValue(storedValue);
            vlessGuidePreference.loaded = true;
            applyVlessGuidePreference(resolvedValue);
            return resolvedValue;
        }

        async function saveVlessGuidePreference(dontShow) {
            applyVlessGuidePreference(dontShow);
            vlessGuidePreference.loaded = true;
            const encoded = dontShow ? "1" : "0";

            try {
                window.localStorage?.setItem(VLESS_GUIDE_HIDE_KEY, encoded);
            } catch (_err) {
                // ignore localStorage failures
            }

            try {
                await cloudStorageSetItem(VLESS_GUIDE_HIDE_KEY, encoded);
            } catch (err) {
                console.warn("CloudStorage set vless_guide_hide failed:", err);
            }
        }

        function applyCloudVisibility(me) {
            const enabled = me?.features?.cloud_enabled !== false;
            uiFeatures.cloudEnabled = enabled;
            homeCloudBtnEl?.classList.toggle("hidden", !enabled);
            applyNavSecondButtonConfig();
            if (!enabled) {
                cloudPageContextEl?.classList.add("hidden");
                if (getActiveScreenId() === "screen-cloud") {
                    switchScreen("screen-home");
                }
            }
        }

        function updateCloudUpButton() {
            if (!cloudUpBtnEl) return;
            const canGoUp = normalizeCloudPath(cloudState.path) !== "/";
            const hideForTelegramBack = hasTelegramBackButton();
            cloudUpBtnEl.classList.toggle("hidden", !canGoUp || hideForTelegramBack);
        }

        function hasTelegramBackButton() {
            const backButton = window.Telegram?.WebApp?.BackButton;
            return Boolean(backButton && typeof backButton.show === "function" && typeof backButton.hide === "function");
        }

        function setCustomBackButtonsVisibility(visible) {
            workBackButtons.forEach((btn) => btn.classList.toggle("hidden", !visible));
            connectionsBackBtnEl?.classList.toggle("hidden", !visible);
            if (!visible) {
                cloudUpBtnEl?.classList.add("hidden");
                return;
            }
            updateCloudUpButton();
        }

        function handleTelegramBack() {
            const activeScreenId = getActiveScreenId();
            if (
                activeScreenId === "screen-work"
                && workInboundOverlayEl
                && !workInboundOverlayEl.classList.contains("hidden")
            ) {
                closeWorkInboundOverlay();
                return;
            }
            if (
                activeScreenId === "screen-cloud"
                && cloudPreviewOverlayEl
                && !cloudPreviewOverlayEl.classList.contains("hidden")
            ) {
                closeCloudPreview();
                return;
            }
            if (activeScreenId === "screen-connections" && !connectionsDetailPageEl?.classList.contains("hidden")) {
                openConnectionsMenu();
                return;
            }
            if (activeScreenId === "screen-connections") {
                switchScreen("screen-home");
                return;
            }

            if (activeScreenId === "screen-cloud") {
                if (normalizeCloudPath(cloudState.path) !== "/") {
                    loadCloudPath(cloudParentPath(cloudState.path)).catch((err) => {
                        console.error("cloud back error:", err);
                    });
                    return;
                }
                switchScreen("screen-home");
                return;
            }
            if (activeScreenId === "screen-settings") {
                switchScreen("screen-profile");
                return;
            }

            if (activeScreenId === "screen-work") {
                const activePageId = getActiveWorkPageId();
                const backTarget = workBackTargetByPage.get(activePageId);
                if (backTarget) {
                    switchWorkPage(backTarget);
                }
            }
        }

        function shouldShowTelegramBackButton() {
            const activeScreenId = getActiveScreenId();

            if (activeScreenId === "screen-connections") {
                return true;
            }

            if (activeScreenId === "screen-work") {
                const activePageId = getActiveWorkPageId();
                return Boolean(workBackTargetByPage.get(activePageId));
            }

            if (activeScreenId === "screen-cloud") {
                return true;
            }
            if (activeScreenId === "screen-settings") {
                return true;
            }

            return false;
        }

        function updateTelegramBackButton() {
            const backButton = window.Telegram?.WebApp?.BackButton;
            if (!backButton) return;

            const shouldShow = shouldShowTelegramBackButton();
            if (shouldShow) {
                if (!tgBackButtonBound && typeof backButton.onClick === "function") {
                    backButton.onClick(handleTelegramBack);
                    tgBackButtonBound = true;
                }
                backButton.show?.();
                return;
            }

            backButton.hide?.();
            updateCloudUpButton();
        }

        function syncBackNavigationMode() {
            const useTelegramBack = hasTelegramBackButton();
            document.body.classList.toggle("context-near-system-bar", useTelegramBack);
            setCustomBackButtonsVisibility(!useTelegramBack);
            if (useTelegramBack) {
                updateTelegramBackButton();
            }
            updateCloudUpButton();
        }

        function runRevealAnimation() {
            return new Promise((resolve) => {
                if (!orbWrapper) return resolve();
                const done = () => {
                    orbWrapper.removeEventListener("animationend", done);
                    resolve();
                };
                orbWrapper.addEventListener("animationend", done);
                orbWrapper.classList.add("expand");
                loading.classList.add("exiting");
                setTimeout(resolve, 750); // fallback
            });
        }

        async function showApp(userName) {
            welcomeTitle.textContent = userName ? `Lumica Service • ${userName}` : "Lumica Service";
            await runRevealAnimation();
            loading.classList.add("hidden");
            statusCard.classList.add("hidden");
            appContent.classList.remove("hidden");
            mainEl.classList.remove("hidden");
            // плавное появление контента
            requestAnimationFrame(() => {
                mainEl.classList.add("visible");
            });
        }

        function showError(message) {
            loading.classList.add("hidden");
            mainEl.classList.remove("hidden");
            requestAnimationFrame(() => {
                mainEl.classList.add("visible");
            });
            statusTitle.textContent = "Доступ закрыт";
            statusText.textContent = message || "Валидация Telegram initData не прошла, повторите запуск мини‑приложения.";
            appContent.classList.add("hidden");
            statusCard.classList.remove("hidden");
        }

        const DEV_MODE = new URLSearchParams(window.location.search).get("dev") === "1";
        console.log("DEV_MODE", DEV_MODE);

        function fmtDate(iso) {
            if (!iso) return "не задано";
            const d = new Date(iso);
            if (Number.isNaN(d.getTime())) return "не задано";
            return d.toLocaleDateString("ru-RU", { day: "2-digit", month: "long", year: "numeric" });
        }

        function normalizeSubscriptionStatus(status) {
            return String(status || "").trim().toLowerCase();
        }

        function isSubscriptionActive(subscription) {
            const status = normalizeSubscriptionStatus(subscription?.status);
            return status === "active" || status === "lifetime";
        }

        function isSubscriptionLifetime(subscription) {
            return normalizeSubscriptionStatus(subscription?.status) === "lifetime";
        }

        function formatSubscriptionUntil(subscription, formatter = fmtDateTime) {
            if (!subscription) return "\u2014";
            if (isSubscriptionLifetime(subscription)) return "\u0411\u0435\u0441\u0441\u0440\u043e\u0447\u043d\u043e";
            return subscription?.access_until ? formatter(subscription.access_until) : "\u2014";
        }

        function maskTelegramId(raw) {
            if (!raw) return "—";
            const text = String(raw);
            if (text.length <= 4) return text;
            return `••••${text.slice(-4)}`;
        }

        function renderTelegramId() {
            const telegramId = lastUserPayload?.user?.telegram_id;
            if (!telegramId) {
                profileTelegramIdEl.textContent = "—";
                profileIdToggleEl.textContent = "Нет";
                return;
            }
            profileTelegramIdEl.textContent = showFullTelegramId ? String(telegramId) : maskTelegramId(telegramId);
            profileIdToggleEl.textContent = showFullTelegramId ? "Скрыть" : "Показать";
        }

        function fmtConnectionsCount(n) {
            const value = Number(n) || 0;
            const mod10 = value % 10;
            const mod100 = value % 100;
            if (mod10 === 1 && mod100 !== 11) return `${value} подключение`;
            if (mod10 >= 2 && mod10 <= 4 && (mod100 < 10 || mod100 >= 20)) return `${value} подключения`;
            return `${value} подключений`;
        }

        function normalizeVlessConnections(payload) {
            const rows = Array.isArray(payload?.connections) ? payload.connections : [];
            if (rows.length) {
                return rows.filter((row) => row?.vless_url);
            }
            if (payload?.ok && payload?.vless_url) {
                return [
                    {
                        label: payload?.identifier || "VLESS",
                        host: payload?.host,
                        port: payload?.port,
                        vless_url: payload?.vless_url,
                        inbound_remark: null,
                    },
                ];
            }
            return [];
        }

        function normalizeMixedConnections(payload) {
            const rows = Array.isArray(payload?.connections) ? payload.connections : [];
            if (rows.length) {
                return rows.filter((row) => Array.isArray(row?.urls) && row.urls.length);
            }
            if (payload?.ok && Array.isArray(payload?.urls) && payload.urls.length) {
                return [
                    {
                        label: payload?.username || "MIXED",
                        host: payload?.host,
                        port: payload?.port,
                        username: payload?.username || null,
                        password: payload?.password || null,
                        urls: payload?.urls,
                        inbound_remark: null,
                    },
                ];
            }
            return [];
        }

        function normalizeHttpConnections(payload) {
            const rows = Array.isArray(payload?.connections) ? payload.connections : [];
            if (rows.length) {
                return rows.filter((row) => Array.isArray(row?.urls) && row.urls.length);
            }
            if (payload?.ok && Array.isArray(payload?.urls) && payload.urls.length) {
                return [
                    {
                        label: payload?.username || "HTTP",
                        host: payload?.host,
                        port: payload?.port,
                        urls: payload?.urls,
                        inbound_remark: null,
                    },
                ];
            }
            return [];
        }

        function connectionProtocolTitle(protocol) {
            if (protocol === "vless") return "VLESS";
            if (protocol === "http") return "HTTP Proxy";
            if (protocol === "mixed") return "Mixed (SOCKS5)";
            return "Подключения";
        }

        function buildConnectionsInfoText(protocol, rows) {
            const safeRows = Array.isArray(rows) ? rows : [];
            const hosts = [...new Set(safeRows.map((r) => String(r?.host || "").trim()).filter(Boolean))];
            const ports = [...new Set(safeRows.map((r) => String(r?.port ?? "").trim()).filter(Boolean))];

            return [
                "Информация о подключениях",
                `Протокол: ${connectionProtocolTitle(protocol)}`,
                `Хост: ${hosts.join(", ") || "—"}`,
                `Порт: ${ports.join(", ") || "—"}`,
            ].join("\n");
        }

        function detectUrlType(url) {
            const raw = String(url || "").trim().toLowerCase();
            if (raw.startsWith("vless://")) return "VLESS";
            if (raw.startsWith("socks5://")) return "SOCKS5";
            if (raw.startsWith("https://")) return "HTTPS";
            if (raw.startsWith("http://")) return "HTTP";
            return "Ссылка";
        }

        function buildTelegramSocksUrl(row) {
            const host = String(row?.host || "").trim();
            const port = String(row?.port ?? "").trim();
            const user = String(row?.username || row?.identifier || "").trim();
            const pass = String(row?.password || "").trim();
            if (!host || !port || !user || !pass) return "";
            return `https://t.me/socks?server=${encodeURIComponent(host)}&port=${encodeURIComponent(port)}&user=${encodeURIComponent(user)}&pass=${encodeURIComponent(pass)}`;
        }

        function openExternalLink(url) {
            const link = String(url || "").trim();
            if (!link) return;
            if (link.startsWith("https://t.me/") && window.Telegram?.WebApp?.openTelegramLink) {
                window.Telegram.WebApp.openTelegramLink(link);
                return;
            }
            if (window.Telegram?.WebApp?.openLink) {
                window.Telegram.WebApp.openLink(link);
                return;
            }
            window.open(link, "_blank", "noopener,noreferrer");
        }

        async function copyToClipboard(value) {
            const text = String(value || "").trim();
            if (!text) throw new Error("empty value");
            if (navigator.clipboard?.writeText) {
                await navigator.clipboard.writeText(text);
                return;
            }
            const ta = document.createElement("textarea");
            ta.value = text;
            ta.setAttribute("readonly", "");
            ta.style.position = "fixed";
            ta.style.left = "-1000px";
            ta.style.top = "-1000px";
            document.body.appendChild(ta);
            ta.select();
            document.execCommand("copy");
            document.body.removeChild(ta);
        }
        const VLESS_SETUP_GUIDE_SHORT = [
            "1. Установи VPN-клиент с поддержкой VLESS (например, Amnezia VPN).",
            "2. Нажми «Копировать VLESS» и вставь ссылку в приложение.",
            "3. Подключись к серверу и проверь доступ к нужным сервисам.",
            "",
            "Совет: включи раздельное туннелирование и оставь VPN только для нужных приложений.",
        ].join("\n");

        function ensureVlessGuideOverlayMounted() {
            if (!vlessGuideOverlayEl) return;
            if (vlessGuideOverlayEl.parentElement !== document.body) {
                document.body.appendChild(vlessGuideOverlayEl);
            }
        }

        async function openVlessGuide() {
            if (!vlessGuideOverlayEl || !vlessGuideTextEl) return;
            if (!vlessGuidePreference.loaded) {
                await loadVlessGuidePreference();
            }
            if (vlessGuidePreference.dontShow) {
                return;
            }
            ensureVlessGuideOverlayMounted();
            applyVlessGuidePreference(vlessGuidePreference.dontShow);
            vlessGuideTextEl.textContent = VLESS_SETUP_GUIDE_SHORT;
            vlessGuideOverlayEl.classList.remove("hidden");
            vlessGuideOverlayEl.setAttribute("aria-hidden", "false");
        }

        function closeVlessGuide() {
            if (!vlessGuideOverlayEl) return;
            vlessGuideOverlayEl.classList.add("hidden");
            vlessGuideOverlayEl.setAttribute("aria-hidden", "true");
        }

        function connectionCopyItems(protocol, row) {
            if (protocol === "vless") {
                return row?.vless_url
                    ? [{ label: "\u041a\u043e\u043f\u0438\u0440\u043e\u0432\u0430\u0442\u044c VLESS", value: row.vless_url, action: "copy", showGuide: true }]
                    : [];
            }
            if (protocol === "mixed") {
                const user = String(row?.username || row?.identifier || "").trim();
                const pass = String(row?.password || "").trim();
                const tgSocksUrl = buildTelegramSocksUrl(row);
                const actions = [];
                if (pass) actions.push({ label: "Копировать пароль", value: pass, action: "copy" });
                if (tgSocksUrl) {
                    actions.push({ label: "Добавить в Тг", value: tgSocksUrl, action: "open" });
                }
                return actions;
            }
            const urls = Array.isArray(row?.urls) ? row.urls : [];
            return urls
                .filter(Boolean)
                .map((url) => ({ label: `Копировать ${detectUrlType(url)}`, value: url, action: "copy" }));
        }

        function openConnectionsMenu() {
            connectionsState.activeProtocol = null;
            connectionsMenuPageEl?.classList.remove("hidden");
            connectionsDetailPageEl?.classList.add("hidden");
            updateConnectionsPageContext(null);
            updateScreenMenuContext("screen-connections");
            updateTelegramBackButton();
        }

        function renderConnectionsDetail(protocol) {
            if (!connectionsDetailListEl) return;
            const rows = Array.isArray(connectionsState.entries?.[protocol]) ? connectionsState.entries[protocol] : [];
            const title = connectionProtocolTitle(protocol);
            connectionsDetailTitleEl.textContent = title;
            connectionsDetailTitleEl.title = title;
            updateConnectionsPageContext(protocol);
            connectionsDetailSubtitleEl.textContent = buildConnectionsInfoText(protocol, rows);
            connectionsDetailListEl.innerHTML = "";

            if (!rows.length) {
                const empty = document.createElement("div");
                empty.className = "work-empty";
                empty.textContent = "Подключения не найдены.";
                connectionsDetailListEl.appendChild(empty);
                return;
            }

            rows.forEach((row, idx) => {
                const item = document.createElement("div");
                item.className = "connection-item";

                const itemTitle = document.createElement("div");
                itemTitle.className = "connection-item-title";
                const mixedEmail = String(row?.username || row?.identifier || "").trim();
                const rawTitle = String(row?.label || "").trim();
                let displayTitle = rawTitle || `${title} #${idx + 1}`;
                if (protocol === "mixed" && mixedEmail) {
                    const sameAsEmail = displayTitle.toLowerCase() === mixedEmail.toLowerCase();
                    if (sameAsEmail) {
                        displayTitle = `Подключение #${idx + 1}`;
                    }
                }
                itemTitle.textContent = displayTitle;

                if (protocol === "mixed") {
                    const meta = document.createElement("div");
                    meta.className = "connection-item-meta";

                    const emailLine = document.createElement("div");
                    emailLine.textContent = `Почта: ${mixedEmail || "—"}`;

                    meta.appendChild(emailLine);
                    item.appendChild(meta);
                }

                const copyRow = document.createElement("div");
                copyRow.className = "connection-copy-row";
                const copies = connectionCopyItems(protocol, row);
                copies.forEach((entry) => {
                    const copyBtn = document.createElement("button");
                    copyBtn.type = "button";
                    copyBtn.className = "connection-copy-btn";
                    copyBtn.textContent = entry.label;
                    copyBtn.addEventListener("click", async () => {
                        const baseText = entry.label;
                        try {
                            if (entry.action === "open") {
                                openExternalLink(entry.value);
                                copyBtn.textContent = "Открыто";
                            } else {
                                await copyToClipboard(entry.value);
                                if (entry.showGuide) {
                                    await openVlessGuide();
                                }
                                copyBtn.textContent = "Скопировано";
                            }
                        } catch (_err) {
                            copyBtn.textContent = "Ошибка";
                        }
                        setTimeout(() => {
                            copyBtn.textContent = baseText;
                        }, 1000);
                    });
                    copyRow.appendChild(copyBtn);
                });

                item.appendChild(itemTitle);
                item.appendChild(copyRow);
                connectionsDetailListEl.appendChild(item);
            });
        }

        function openConnectionsDetail(protocol) {
            if (!connectionsState.visibility?.[protocol]) return;
            const rows = Array.isArray(connectionsState.entries?.[protocol]) ? connectionsState.entries[protocol] : [];
            if (!rows.length) return;
            connectionsState.activeProtocol = protocol;
            renderConnectionsDetail(protocol);
            connectionsMenuPageEl?.classList.add("hidden");
            connectionsDetailPageEl?.classList.remove("hidden");
            updateScreenMenuContext("screen-connections");
            updateTelegramBackButton();
        }

        function renderDashboard(data) {
            const me = data?.me;
            const service = data?.status?.services;
            const subscription = me?.subscription;
            const subActive = isSubscriptionActive(subscription);
            const lifetimeSub = isSubscriptionLifetime(subscription);
            const subscriptionUntil = formatSubscriptionUntil(subscription, fmtDate);
            const vless = data?.vless;
            const http = data?.http;
            const mixed = data?.mixed;

            applyCloudVisibility(me);
            lastUserPayload = me || null;
            const userRole = me?.user?.role || "user";
            const isOwner = userRole === "owner";
            profileRoleEl.textContent = userRole;
            workRolePillEl.textContent = userRole;
            workOwnerNameEl.textContent = me?.user?.name || me?.user?.first_name || me?.user?.username || "Панель управления";
            workOwnerRoleEl.textContent = userRole;
            navWorkBtn.classList.toggle("hidden", !isOwner);
            bottomNavEl.classList.toggle("with-work", isOwner);
            if (!isOwner) {
                const activeWork = navWorkBtn.classList.contains("active");
                if (activeWork) switchScreen("screen-home");
            } else {
                loadWorkClientsData().catch((err) => {
                    console.error("load clients error:", err);
                });
            }
            renderTelegramId();

            const showVlessCard = service?.vless?.visible_in_app !== false;
            const showHttpCard = service?.http?.visible_in_app === true;
            const showMixedCard =
                service?.mixed?.visible_in_app === true ||
                (service?.mixed === undefined && service?.https_mixed?.visible_in_app !== false);
            const vlessConnections = normalizeVlessConnections(vless);
            const httpConnections = normalizeHttpConnections(http);
            const mixedConnections = normalizeMixedConnections(mixed);
            connectionsState.visibility.vless = showVlessCard;
            connectionsState.visibility.http = showHttpCard;
            connectionsState.visibility.mixed = showMixedCard;
            connectionsState.entries.vless = showVlessCard ? vlessConnections : [];
            connectionsState.entries.http = showHttpCard ? httpConnections : [];
            connectionsState.entries.mixed = showMixedCard ? mixedConnections : [];
            vlessCardEl?.classList.toggle("hidden", !showVlessCard);
            httpCardEl?.classList.toggle("hidden", !showHttpCard);
            mixedCardEl?.classList.toggle("hidden", !showMixedCard);
            connectionsHiddenNoteEl?.classList.toggle("hidden", showVlessCard || showHttpCard || showMixedCard);
            if (connectionsState.activeProtocol && !connectionsState.visibility[connectionsState.activeProtocol]) {
                openConnectionsMenu();
            } else if (connectionsState.activeProtocol) {
                renderConnectionsDetail(connectionsState.activeProtocol);
            }

            homeServerSub.textContent = service?.vless?.ok || service?.https_mixed?.ok ? "Сервисы доступны" : "Сервисы недоступны";
            if (subActive) {
                homeSubTitle.textContent = "Подписка активна";
                homeSubSub.textContent = "Доступ подтвержден";
                homeSubRight.textContent = lifetimeSub ? "Без срока" : `До: ${subscriptionUntil}`;
                profileSubTitleEl.textContent = "Подписка активна";
                profileSubSubEl.textContent = lifetimeSub ? "Доступ: бессрочно" : `Доступ до: ${subscriptionUntil}`;
                document.getElementById("hero-sub").textContent = lifetimeSub ? "Бессрочная подписка" : `Подписка до ${subscriptionUntil}`;
            } else {
                homeSubTitle.textContent = "Подписка неактивна";
                homeSubSub.textContent = "Оформите/продлите доступ";
                homeSubRight.textContent = "—";
                profileSubTitleEl.textContent = "Подписка неактивна";
                profileSubSubEl.textContent = "Доступ ограничен";
                document.getElementById("hero-sub").textContent = "Требуется активная подписка";
            }

            if (vlessConnections.length) {
                vlessStatusEl.textContent = `Готово • ${fmtConnectionsCount(vlessConnections.length)}`;
                vlessDetailEl.textContent = "›";
            } else {
                vlessStatusEl.textContent = "Не выдано";
                vlessDetailEl.textContent = "—";
            }

            if (httpConnections.length) {
                httpStatusEl.textContent = `Готово • ${fmtConnectionsCount(httpConnections.length)}`;
                httpDetailEl.textContent = "›";
            } else {
                httpStatusEl.textContent = "Не выдано";
                httpDetailEl.textContent = "—";
            }

            if (mixedConnections.length) {
                mixedStatusEl.textContent = `Готово • ${fmtConnectionsCount(mixedConnections.length)}`;
                mixedDetailEl.textContent = "›";
            } else {
                mixedStatusEl.textContent = "Не выдано";
                mixedDetailEl.textContent = "—";
            }
        }

        async function fetchJson(url, optional = false) {
            const response = await fetch(url, {
                method: "GET",
                credentials: "same-origin",
            });
            let payload = {};
            try {
                payload = await response.json();
            } catch (_e) {
                payload = {};
            }
            if (!response.ok || payload?.ok === false) {
                if (optional) return null;
                throw new Error(payload.error || `Ошибка запроса ${url}`);
            }
            return payload;
        }

        function withCsrfHeaders(headers = {}) {
            const merged = { ...headers };
            if (csrfToken) {
                merged["X-CSRF-Token"] = csrfToken;
            }
            return merged;
        }

        async function postJson(url, body = null) {
            const response = await fetch(url, {
                method: "POST",
                credentials: "same-origin",
                headers: withCsrfHeaders({ "Content-Type": "application/json" }),
                body: body ? JSON.stringify(body) : null,
            });
            let payload = {};
            try {
                payload = await response.json();
            } catch (_e) {
                payload = {};
            }
            if (!response.ok || payload?.ok === false) {
                throw new Error(payload.error || `Ошибка запроса ${url}`);
            }
            return payload;
        }

        async function deleteJson(url) {
            const response = await fetch(url, {
                method: "DELETE",
                credentials: "same-origin",
                headers: withCsrfHeaders(),
            });
            let payload = {};
            try {
                payload = await response.json();
            } catch (_e) {
                payload = {};
            }
            if (!response.ok || payload?.ok === false) {
                throw new Error(payload.error || `Ошибка запроса ${url}`);
            }
            return payload;
        }

        function fmtCloudSize(sizeBytes) {
            const value = Number(sizeBytes);
            if (!Number.isFinite(value) || value < 0) return "—";
            if (value < 1024) return `${value} Б`;
            const units = ["КБ", "МБ", "ГБ", "ТБ"];
            let current = value;
            let unitIdx = -1;
            while (current >= 1024 && unitIdx < units.length - 1) {
                current /= 1024;
                unitIdx += 1;
            }
            return `${current.toFixed(current >= 100 ? 0 : 1)} ${units[unitIdx]}`;
        }

        function cloudFileExtension(fileNode) {
            const fileMeta = fileNode?.file || {};
            const extFromMeta = String(fileMeta?.extension || "")
                .trim()
                .toLowerCase()
                .replace(/^\./, "");
            if (extFromMeta) return extFromMeta;

            const rawName = String(fileMeta?.original_name || fileNode?.name || "").trim();
            const dotIndex = rawName.lastIndexOf(".");
            if (dotIndex <= 0 || dotIndex >= rawName.length - 1) return "";
            return rawName.slice(dotIndex + 1).toLowerCase();
        }

        function cloudFileIcon(fileNode) {
            const fileMeta = fileNode?.file || {};
            const mime = String(fileMeta?.mime_type || "").trim().toLowerCase();
            const ext = cloudFileExtension(fileNode);

            if (mime.startsWith("audio/") || cloudAudioExtensions.has(ext)) return "🎵";
            if (mime.startsWith("video/") || cloudVideoExtensions.has(ext)) return "🎬";
            if (mime.startsWith("image/") || cloudImageExtensions.has(ext)) return "🖼️";
            if (
                mime.includes("zip")
                || mime.includes("compressed")
                || mime.includes("archive")
                || mime.includes("x-7z")
                || mime.includes("x-rar")
                || cloudArchiveExtensions.has(ext)
            ) {
                return "🗜️";
            }
            if (mime === "application/pdf" || ext === "pdf") return "📕";
            if (cloudSheetExtensions.has(ext) || mime.includes("spreadsheet") || mime.includes("excel") || mime.includes("csv")) return "📊";
            if (cloudSlideExtensions.has(ext) || mime.includes("presentation") || mime.includes("powerpoint")) return "📽️";
            if (cloudDocumentExtensions.has(ext) || mime.includes("wordprocessingml") || mime.includes("msword")) return "📘";
            if (cloudCodeExtensions.has(ext)) return "💻";
            if (mime.startsWith("text/") || ["txt", "md", "log", "rtf"].includes(ext)) return "📝";
            return "📄";
        }

        function cloudFilePreviewKind(fileNode) {
            const fileMeta = fileNode?.file || {};
            const mime = String(fileMeta?.mime_type || "").trim().toLowerCase();
            const ext = cloudFileExtension(fileNode);
            if (mime.startsWith("video/") || cloudVideoExtensions.has(ext)) return "video";
            if (mime.startsWith("audio/") || cloudAudioExtensions.has(ext)) return "audio";
            return "";
        }

        function cloudInlineFileUrl(fileId) {
            return `${cloudDownloadFileUrl(fileId)}?inline=1`;
        }

        function setCloudPreviewNote(text = "", tone = "info") {
            if (!cloudPreviewNoteEl) return;
            const message = String(text || "").trim();
            cloudPreviewNoteEl.classList.remove("error", "success");
            if (!message) {
                cloudPreviewNoteEl.textContent = "";
                cloudPreviewNoteEl.classList.add("hidden");
                return;
            }
            if (tone === "error" || tone === "success") {
                cloudPreviewNoteEl.classList.add(tone);
            }
            cloudPreviewNoteEl.textContent = message;
            cloudPreviewNoteEl.classList.remove("hidden");
        }

        function clearCloudPreviewMedia() {
            if (!cloudPreviewMediaWrapEl) return;
            const media = cloudPreviewMediaWrapEl.querySelector("audio, video");
            if (media) {
                try {
                    media.pause?.();
                } catch (_e) {
                    // no-op
                }
                media.removeAttribute("src");
                media.load?.();
            }
            cloudPreviewMediaWrapEl.innerHTML = "";
        }

        function closeCloudPreview() {
            if (!cloudPreviewOverlayEl) return;
            clearCloudPreviewMedia();
            setCloudPreviewNote("");
            cloudPreviewOverlayEl.classList.add("hidden");
            cloudPreviewOverlayEl.setAttribute("aria-hidden", "true");
        }

        function openCloudPreview(fileNode) {
            const fileMeta = fileNode?.file || {};
            const previewKind = cloudFilePreviewKind(fileNode);
            const fileId = Number(fileMeta?.file_id || 0);
            if (!previewKind || !fileId) return;

            const fileName = String(fileNode?.name || fileMeta?.original_name || "Медиафайл");
            if (!cloudPreviewOverlayEl || !cloudPreviewMediaWrapEl || !cloudPreviewTitleEl) {
                window.open(cloudInlineFileUrl(fileId), "_blank", "noopener");
                return;
            }

            clearCloudPreviewMedia();
            setCloudPreviewNote("");
            cloudPreviewTitleEl.textContent = fileName;
            cloudPreviewTitleEl.title = fileName;

            const mediaEl = document.createElement(previewKind);
            mediaEl.controls = true;
            mediaEl.autoplay = true;
            mediaEl.preload = "metadata";
            mediaEl.src = cloudInlineFileUrl(fileId);
            mediaEl.className = previewKind === "video" ? "cloud-preview-video" : "cloud-preview-audio";
            if (previewKind === "video") {
                mediaEl.setAttribute("playsinline", "playsinline");
                mediaEl.setAttribute("webkit-playsinline", "webkit-playsinline");
            }
            mediaEl.addEventListener("error", () => {
                setCloudPreviewNote("Не удалось воспроизвести файл. Попробуйте скачать его кнопкой.", "error");
            });

            cloudPreviewMediaWrapEl.appendChild(mediaEl);
            cloudPreviewOverlayEl.classList.remove("hidden");
            cloudPreviewOverlayEl.setAttribute("aria-hidden", "false");
        }

        function setCloudStatus(text = "", tone = "info") {
            if (!cloudStatusNoteEl) return;
            const message = String(text || "").trim();
            cloudStatusNoteEl.classList.remove("error", "success");
            if (!message) {
                cloudStatusNoteEl.textContent = "";
                cloudStatusNoteEl.classList.add("hidden");
                return;
            }
            if (tone === "error" || tone === "success") {
                cloudStatusNoteEl.classList.add(tone);
            }
            cloudStatusNoteEl.textContent = message;
            cloudStatusNoteEl.classList.remove("hidden");
        }

        function setCloudUploadProgress(percent, text = "") {
            const safePercent = Math.max(0, Math.min(100, Number(percent) || 0));
            if (cloudUploadProgressBarEl) {
                cloudUploadProgressBarEl.style.width = `${safePercent}%`;
            }
            if (cloudUploadProgressEl) {
                cloudUploadProgressEl.classList.remove("hidden");
                cloudUploadProgressEl.setAttribute("aria-valuenow", String(Math.round(safePercent)));
            }
            if (cloudUploadProgressTextEl) {
                cloudUploadProgressTextEl.textContent = text || `${Math.round(safePercent)}%`;
                cloudUploadProgressTextEl.classList.remove("hidden");
            }
        }

        function resetCloudUploadProgress(hide = true) {
            if (cloudUploadProgressBarEl) {
                cloudUploadProgressBarEl.style.width = "0%";
            }
            if (cloudUploadProgressEl) {
                cloudUploadProgressEl.setAttribute("aria-valuenow", "0");
                if (hide) {
                    cloudUploadProgressEl.classList.add("hidden");
                }
            }
            if (cloudUploadProgressTextEl) {
                cloudUploadProgressTextEl.textContent = "0%";
                if (hide) {
                    cloudUploadProgressTextEl.classList.add("hidden");
                }
            }
        }

        async function uploadSingleCloudFile(file, targetPath, onProgress) {
            return new Promise((resolve, reject) => {
                const xhr = new XMLHttpRequest();
                xhr.open("POST", cloudUploadUrl, true);
                xhr.withCredentials = true;
                xhr.timeout = 0;
                if (csrfToken) {
                    xhr.setRequestHeader("X-CSRF-Token", csrfToken);
                }

                xhr.upload.onprogress = (event) => {
                    if (!onProgress) return;
                    const total = event.lengthComputable ? Number(event.total) : Number(file?.size || 0);
                    onProgress(Number(event.loaded || 0), total);
                };

                xhr.onerror = () => {
                    reject(new Error("Сетевая ошибка при загрузке"));
                };
                xhr.ontimeout = () => {
                    reject(new Error("Таймаут загрузки файла"));
                };
                xhr.onabort = () => {
                    reject(new Error("Загрузка отменена"));
                };
                xhr.onload = () => {
                    let payload = {};
                    try {
                        payload = JSON.parse(xhr.responseText || "{}");
                    } catch (_e) {
                        payload = {};
                    }
                    if (xhr.status >= 200 && xhr.status < 300 && payload?.ok !== false) {
                        resolve(payload);
                        return;
                    }

                    const rawText = String(xhr.responseText || "").trim();
                    const serverError = String(payload?.error || "").trim();
                    const looksLikeHtml = /^<!doctype|^<html/i.test(rawText);
                    const fallbackByStatus =
                        xhr.status === 413
                            ? "Файл слишком большой для nginx (лимит client_max_body_size)"
                            : xhr.status === 504
                                ? "Nginx не дождался ответа бэкенда (увеличьте proxy_read_timeout/proxy_send_timeout)"
                                : xhr.status === 502
                                    ? "Ошибка шлюза между nginx и бэкендом/Telegram"
                            : xhr.statusText || `HTTP ${xhr.status}`;
                    const detail =
                        serverError
                        || (xhr.status === 413
                            ? fallbackByStatus
                            : (!looksLikeHtml && rawText ? rawText : fallbackByStatus));
                    reject(new Error(`${detail} (HTTP ${xhr.status})`));
                };

                const formData = new FormData();
                formData.append("path", targetPath);
                formData.append("file", file, file.name);
                xhr.send(formData);
            });
        }

        function renderCloudList() {
            if (!cloudListEl) return;
            cloudListEl.innerHTML = "";
            const folders = Array.isArray(cloudState.folders) ? cloudState.folders : [];
            const files = Array.isArray(cloudState.files) ? cloudState.files : [];

            if (!folders.length && !files.length) {
                const empty = document.createElement("div");
                empty.className = "work-empty";
                empty.textContent = "Папка пуста. Загрузите файл или создайте папку.";
                cloudListEl.appendChild(empty);
                return;
            }

            folders.forEach((folder) => {
                const row = document.createElement("div");
                row.className = "cloud-node-card";

                const head = document.createElement("div");
                head.className = "cloud-node-head";

                const openBtn = document.createElement("button");
                openBtn.type = "button";
                openBtn.className = "cloud-node-open";
                openBtn.textContent = `📁 ${folder.name || "Папка"}`;
                openBtn.addEventListener("click", () => {
                    loadCloudPath(folder.path || "/").catch((err) => {
                        console.error("open folder error:", err);
                        setCloudStatus(err.message || "Не удалось открыть папку", "error");
                    });
                });

                const actions = document.createElement("div");
                actions.className = "cloud-node-actions";

                const deleteBtn = document.createElement("button");
                deleteBtn.type = "button";
                deleteBtn.className = "cloud-node-action danger";
                deleteBtn.textContent = "Удалить";
                deleteBtn.addEventListener("click", async () => {
                    if (!window.confirm(`Удалить папку "${folder.name}"?`)) return;
                    try {
                        await deleteJson(cloudDeleteNodeUrl(folder.node_id));
                        await loadCloudPath(cloudState.path);
                        setCloudStatus(`Папка "${folder.name}" удалена`, "success");
                    } catch (err) {
                        console.error("delete folder error:", err);
                        setCloudStatus(err.message || "Не удалось удалить папку", "error");
                    }
                });

                actions.appendChild(deleteBtn);
                head.appendChild(openBtn);
                head.appendChild(actions);

                const sub = document.createElement("div");
                sub.className = "cloud-node-sub";
                sub.textContent = "Папка";

                row.appendChild(head);
                row.appendChild(sub);
                cloudListEl.appendChild(row);
            });

            files.forEach((fileNode) => {
                const fileMeta = fileNode?.file || {};
                const isReady = String(fileMeta?.status || "").toLowerCase() === "ready";
                const previewKind = cloudFilePreviewKind(fileNode);
                const canPreview = Boolean(previewKind && isReady && fileMeta?.file_id);

                const row = document.createElement("div");
                row.className = "cloud-node-card";

                const head = document.createElement("div");
                head.className = "cloud-node-head";

                const title = document.createElement(canPreview ? "button" : "div");
                if (canPreview) {
                    title.type = "button";
                }
                title.className = `cloud-node-open${canPreview ? " previewable" : ""}`;
                title.textContent = `${cloudFileIcon(fileNode)} ${fileNode?.name || "Файл"}`;
                if (canPreview) {
                    title.title = previewKind === "video" ? "Открыть видео" : "Открыть аудио";
                    title.addEventListener("click", () => {
                        openCloudPreview(fileNode);
                    });
                } else {
                    title.style.cursor = "default";
                }

                const actions = document.createElement("div");
                actions.className = "cloud-node-actions";

                const downloadBtn = document.createElement("button");
                downloadBtn.type = "button";
                downloadBtn.className = "cloud-node-action";
                downloadBtn.textContent = "Скачать";
                downloadBtn.disabled = !isReady || !fileMeta?.file_id;
                downloadBtn.addEventListener("click", () => {
                    if (!fileMeta?.file_id || !isReady) return;
                    const a = document.createElement("a");
                    a.href = cloudDownloadFileUrl(fileMeta.file_id);
                    a.download = String(fileMeta.original_name || fileNode?.name || "download.bin");
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    setCloudStatus(`Скачивание: ${fileNode?.name || "файл"}`, "success");
                });

                const deleteBtn = document.createElement("button");
                deleteBtn.type = "button";
                deleteBtn.className = "cloud-node-action danger";
                deleteBtn.textContent = "Удалить";
                deleteBtn.addEventListener("click", async () => {
                    if (!window.confirm(`Удалить файл "${fileNode?.name}"?`)) return;
                    try {
                        await deleteJson(cloudDeleteNodeUrl(fileNode.node_id));
                        await loadCloudPath(cloudState.path);
                        setCloudStatus(`Файл "${fileNode?.name}" удален`, "success");
                    } catch (err) {
                        console.error("delete file error:", err);
                        setCloudStatus(err.message || "Не удалось удалить файл", "error");
                    }
                });

                actions.appendChild(downloadBtn);
                actions.appendChild(deleteBtn);
                head.appendChild(title);
                head.appendChild(actions);

                const sizeText = fmtCloudSize(fileMeta?.size_bytes);
                const chunksText = Number(fileMeta?.chunk_count) > 0 ? `${fileMeta.chunk_count} чанк(ов)` : "0 чанков";
                const statusText = fileMeta?.status || "unknown";
                const sub = document.createElement("div");
                sub.className = "cloud-node-sub";
                sub.textContent = `${sizeText} • ${chunksText} • ${statusText}`;

                row.appendChild(head);
                row.appendChild(sub);
                cloudListEl.appendChild(row);
            });
        }

        async function loadCloudPath(path, options = {}) {
            const preserveStatus = Boolean(options?.preserveStatus);
            const nextPath = normalizeCloudPath(path || "/");
            cloudState.path = nextPath;
            if (cloudPathEl) {
                cloudPathEl.textContent = nextPath;
                cloudPathEl.title = nextPath;
            }
            updateCloudPageContext(nextPath);
            updateCloudUpButton();
            updateTelegramBackButton();

            if (cloudListEl) {
                cloudListEl.innerHTML = '<div class="work-empty">Загрузка...</div>';
            }
            try {
                const payload = await fetchJson(`${cloudListUrl}?path=${encodeURIComponent(nextPath)}`, false);
                cloudState.folders = Array.isArray(payload?.folders) ? payload.folders : [];
                cloudState.files = Array.isArray(payload?.files) ? payload.files : [];
                cloudState.path = normalizeCloudPath(payload?.path || nextPath);
                if (cloudPathEl) {
                    cloudPathEl.textContent = cloudState.path;
                    cloudPathEl.title = cloudState.path;
                }
                updateCloudPageContext(cloudState.path);
                cloudState.initialized = true;
                renderCloudList();
                if (!preserveStatus) {
                    setCloudStatus("");
                }
            } catch (err) {
                const message = String(err?.message || "Не удалось загрузить облако");
                if (nextPath !== "/" && message.toLowerCase().includes("folder not found")) {
                    return loadCloudPath(cloudParentPath(nextPath), options);
                }
                cloudState.folders = [];
                cloudState.files = [];
                if (cloudListEl) {
                    cloudListEl.innerHTML = '<div class="work-empty">Не удалось загрузить содержимое облака.</div>';
                }
                setCloudStatus(message, "error");
                throw err;
            } finally {
                updateCloudUpButton();
                updateTelegramBackButton();
            }
        }

        async function ensureCloudLoaded(force = false) {
            updateCloudPageContext(cloudState.path);
            if (!force && cloudState.initialized) {
                updateCloudUpButton();
                return;
            }
            await loadCloudPath(cloudState.path);
        }

        async function createCloudFolder() {
            const rawName = window.prompt("Введите имя папки");
            if (rawName === null) return;
            const name = String(rawName).trim();
            if (!name) {
                setCloudStatus("Имя папки не может быть пустым", "error");
                return;
            }
            try {
                const result = await postJson(cloudMkdirUrl, {
                    parent_path: cloudState.path,
                    name,
                });
                await loadCloudPath(cloudState.path);
                setCloudStatus(
                    result?.existing ? `Папка "${name}" уже существует` : `Папка "${name}" создана`,
                    result?.existing ? "info" : "success"
                );
            } catch (err) {
                console.error("mkdir error:", err);
                setCloudStatus(err.message || "Не удалось создать папку", "error");
            }
        }

        async function uploadCloudFiles(fileList) {
            const files = Array.from(fileList || []);
            if (!files.length || cloudState.isUploading) return;

            cloudState.isUploading = true;
            cloudUploadInputEl && (cloudUploadInputEl.disabled = true);
            cloudUploadLabelEl?.classList.add("disabled");
            cloudNewFolderBtnEl && (cloudNewFolderBtnEl.disabled = true);
            cloudUpBtnEl && (cloudUpBtnEl.disabled = true);

            let uploaded = 0;
            let failed = 0;
            const uploadErrors = [];
            const totalBytes = files.reduce((sum, file) => sum + Math.max(0, Number(file?.size) || 0), 0);
            const totalFiles = files.length;
            let processedBytes = 0;
            resetCloudUploadProgress(false);
            setCloudUploadProgress(0, "Загрузка: 0%");

            try {
                for (const file of files) {
                    const fileSize = Math.max(0, Number(file?.size) || 0);
                    setCloudStatus(`Загрузка: ${file.name}`);
                    try {
                        await uploadSingleCloudFile(file, cloudState.path, (loaded, total) => {
                            const effectiveTotal = total > 0 ? total : fileSize;
                            let percent = 0;
                            if (totalBytes > 0) {
                                const safeLoaded = Math.max(0, Math.min(Number(loaded || 0), effectiveTotal || Number(loaded || 0)));
                                const overallLoaded = Math.min(processedBytes + safeLoaded, totalBytes);
                                percent = (overallLoaded / totalBytes) * 100;
                            } else {
                                const perFileProgress = effectiveTotal > 0 ? Math.min(Number(loaded || 0) / effectiveTotal, 1) : 0;
                                percent = ((uploaded + perFileProgress) / totalFiles) * 100;
                            }
                            setCloudUploadProgress(percent, `Загрузка: ${Math.round(percent)}%`);
                        });
                        uploaded += 1;
                    } catch (err) {
                        failed += 1;
                        console.error("upload error:", err);
                        const reason = String(err?.message || "upload failed").trim();
                        uploadErrors.push({
                            fileName: file.name,
                            reason,
                        });
                    } finally {
                        processedBytes += fileSize;
                        const processedFiles = uploaded + failed;
                        const percent =
                            totalBytes > 0
                                ? (processedBytes / totalBytes) * 100
                                : (processedFiles / totalFiles) * 100;
                        setCloudUploadProgress(percent, `Загрузка: ${Math.round(percent)}%`);
                    }
                }

                await loadCloudPath(cloudState.path, { preserveStatus: true });
                if (failed === 0) {
                    setCloudUploadProgress(100, "Загрузка: 100%");
                    setCloudStatus(`Загружено файлов: ${uploaded}`, "success");
                    setTimeout(() => {
                        if (!cloudState.isUploading) {
                            resetCloudUploadProgress(true);
                        }
                    }, 1200);
                    return;
                }

                const firstError = uploadErrors[0];
                if (uploaded === 0 && failed === 1 && firstError) {
                    setCloudStatus(`Ошибка загрузки "${firstError.fileName}": ${firstError.reason}`, "error");
                    return;
                }

                const summary = `Загружено: ${uploaded}, ошибок: ${failed}`;
                if (firstError) {
                    const prefix = failed > 1 ? "Первая ошибка" : "Ошибка";
                    setCloudStatus(`${summary}. ${prefix}: "${firstError.fileName}" — ${firstError.reason}`, "error");
                    return;
                }
                setCloudStatus(summary, "error");
            } finally {
                cloudState.isUploading = false;
                cloudUploadInputEl && (cloudUploadInputEl.disabled = false);
                cloudUploadLabelEl?.classList.remove("disabled");
                cloudNewFolderBtnEl && (cloudNewFolderBtnEl.disabled = false);
                cloudUpBtnEl && (cloudUpBtnEl.disabled = false);
            }
        }

        function fillSelect(el, items, mapLabel, mapValue, emptyText) {
            if (!el) return;
            el.innerHTML = "";
            const empty = document.createElement("option");
            empty.value = "";
            empty.textContent = emptyText;
            el.appendChild(empty);
            items.forEach((item, idx) => {
                const opt = document.createElement("option");
                opt.value = mapValue(item, idx);
                opt.textContent = mapLabel(item, idx);
                el.appendChild(opt);
            });
        }

        function inboundOptionLabel(inbound) {
            const panelState = inbound?.enable ? "panel:on" : "panel:off";
            const appState = inbound?.show_in_app ? "app:visible" : "app:hidden";
            return `${inbound.panel_inbound_id} • ${inbound.protocol || "unknown"} • ${inbound.remark || "no-remark"} • ${panelState} • ${appState}`;
        }

        function renderWorkInboundSelectOptions() {
            if (!workInboundSelectEl) return;
            const selected = workInboundSelectEl.value;
            fillSelect(
                workInboundSelectEl,
                workState.inbounds,
                (i) => inboundOptionLabel(i),
                (i) => String(i.panel_inbound_id),
                "Выбери inbound"
            );
            if (selected && workState.inbounds.some((i) => String(i.panel_inbound_id) === selected)) {
                workInboundSelectEl.value = selected;
            }
        }

        function renderWorkPendingInboundSelectOptions() {
            if (!workPendingInboundSelectEl) return;
            const selected = workPendingInboundSelectEl.value;
            fillSelect(
                workPendingInboundSelectEl,
                workState.inbounds,
                (i) => inboundOptionLabel(i),
                (i) => String(i.panel_inbound_id),
                "Выбери inbound"
            );
            if (selected && workState.inbounds.some((i) => String(i.panel_inbound_id) === selected)) {
                workPendingInboundSelectEl.value = selected;
            }
        }

        function fmtDateTime(iso) {
            if (!iso) return "—";
            const d = new Date(iso);
            if (Number.isNaN(d.getTime())) return "—";
            return d.toLocaleString("ru-RU", {
                day: "2-digit",
                month: "2-digit",
                year: "numeric",
                hour: "2-digit",
                minute: "2-digit",
            });
        }

        function fmtMoney(value) {
            if (value === null || value === undefined || value === "") return "—";
            const n = Number(value);
            if (Number.isNaN(n)) return "—";
            return `${n.toLocaleString("ru-RU")} ₽`;
        }

        function fmtMonthsText(months) {
            const m = Number(months) || 0;
            if (m % 10 === 1 && m % 100 !== 11) return `${m} месяц`;
            if (m % 10 >= 2 && m % 10 <= 4 && (m % 100 < 10 || m % 100 >= 20)) return `${m} месяца`;
            return `${m} месяцев`;
        }

        function toInputDateValue(dateObj) {
            if (!(dateObj instanceof Date) || Number.isNaN(dateObj.getTime())) return "";
            const year = dateObj.getFullYear();
            const month = String(dateObj.getMonth() + 1).padStart(2, "0");
            const day = String(dateObj.getDate()).padStart(2, "0");
            return `${year}-${month}-${day}`;
        }

        function defaultSubscriptionDateValue(days = 30) {
            const target = new Date();
            target.setHours(0, 0, 0, 0);
            target.setDate(target.getDate() + Math.max(1, Number(days) || 30));
            return toInputDateValue(target);
        }

        function validateSubscriptionDateValue(rawDate) {
            const clean = String(rawDate || "").trim();
            if (!clean) {
                throw new Error("Укажи дату окончания подписки");
            }
            const ts = Date.parse(`${clean}T00:00:00`);
            if (Number.isNaN(ts)) {
                throw new Error("Неверный формат даты");
            }
            const today = new Date();
            today.setHours(0, 0, 0, 0);
            if (ts < today.getTime()) {
                throw new Error("Дата окончания не может быть в прошлом");
            }
            return `${clean}T23:59:59`;
        }

        function renderWorkSubscriptionControls(sub) {
            const hasSubscription = Boolean(sub);
            const lifetimeSubscription = isSubscriptionLifetime(sub);
            const createAsLifetime =
                !hasSubscription && normalizeSubscriptionStatus(workSubStatusSelectEl?.value) === "lifetime";
            workSubExtendWrapEl?.classList.toggle("hidden", !hasSubscription || lifetimeSubscription);
            workSubCreateWrapEl?.classList.toggle("hidden", hasSubscription || createAsLifetime);

            if (workSubExtendBtnEl) {
                if (!hasSubscription && createAsLifetime) {
                    workSubExtendBtnEl.textContent = "Создать бессрочную подписку";
                } else {
                    workSubExtendBtnEl.textContent = hasSubscription ? "Продлить подписку" : "Создать подписку";
                }
                workSubExtendBtnEl.classList.toggle("hidden", hasSubscription && lifetimeSubscription);
            }

            if (workSubCreateDateEl) {
                if (!hasSubscription && !createAsLifetime && !workSubCreateDateEl.value) {
                    workSubCreateDateEl.value = defaultSubscriptionDateValue(30);
                }
                if (createAsLifetime) {
                    workSubCreateDateEl.value = "";
                }
                if (hasSubscription && !lifetimeSubscription && sub?.access_until) {
                    const accessUntil = new Date(sub.access_until);
                    if (!Number.isNaN(accessUntil.getTime())) {
                        workSubCreateDateEl.value = toInputDateValue(accessUntil);
                    }
                }
            }
        }

        function isValidTelegramId(rawValue) {
            return /^\d+$/.test(String(rawValue || "").trim());
        }

        function setPendingSubscriptionStatus(message, tone = "") {
            if (!workPendingSubSaveStatusEl) return;
            workPendingSubSaveStatusEl.classList.remove("success", "error");
            if (!message) {
                workPendingSubSaveStatusEl.textContent = "";
                workPendingSubSaveStatusEl.classList.add("hidden");
                return;
            }
            if (tone === "success" || tone === "error") {
                workPendingSubSaveStatusEl.classList.add(tone);
            }
            workPendingSubSaveStatusEl.textContent = message;
            workPendingSubSaveStatusEl.classList.remove("hidden");
        }

        function upsertWorkUserFromOverview(overview) {
            const user = overview?.user || null;
            if (!user?.id) return;
            const normalized = {
                id: user.id,
                telegram_id: user.telegram_id,
                username: user.username,
                name: user.name,
                role: user.role,
            };
            const idx = workState.users.findIndex((row) => String(row?.id) === String(user.id));
            if (idx >= 0) {
                workState.users[idx] = { ...workState.users[idx], ...normalized };
            } else {
                workState.users.push(normalized);
                workState.users.sort((a, b) => Number(a?.id || 0) - Number(b?.id || 0));
            }
            renderWorkClientCards();
        }

        function renderPendingSubscriptionControls(sub, options = {}) {
            const preserveDate = Boolean(options?.preserveDate);
            const selectedStatus = normalizeSubscriptionStatus(workPendingSubStatusSelectEl?.value || "active");
            const lifetimeSelected = selectedStatus === "lifetime";

            workPendingSubCreateWrapEl?.classList.toggle("hidden", lifetimeSelected);
            if (workPendingSubSaveBtnEl) {
                if (lifetimeSelected) {
                    workPendingSubSaveBtnEl.textContent = sub ? "Сохранить бессрочную подписку" : "Создать бессрочную подписку";
                } else {
                    workPendingSubSaveBtnEl.textContent = sub ? "Сохранить подписку" : "Создать подписку";
                }
            }

            if (!workPendingSubCreateDateEl) {
                return;
            }
            if (lifetimeSelected) {
                workPendingSubCreateDateEl.value = "";
                return;
            }
            if (preserveDate) {
                if (!workPendingSubCreateDateEl.value) {
                    workPendingSubCreateDateEl.value = defaultSubscriptionDateValue(30);
                }
                return;
            }
            if (sub?.access_until) {
                const accessUntil = new Date(sub.access_until);
                if (!Number.isNaN(accessUntil.getTime())) {
                    workPendingSubCreateDateEl.value = toInputDateValue(accessUntil);
                    return;
                }
            }
            workPendingSubCreateDateEl.value = defaultSubscriptionDateValue(30);
        }

        function renderPendingSubscriptionOverview(overview) {
            workState.pendingOverview = overview || null;
            const sub = overview?.subscription || null;
            const conn = overview?.connections || null;

            if (workPendingSubStatusSelectEl) {
                workPendingSubStatusSelectEl.value = sub?.status || "active";
            }
            if (workPendingSubPriceInputEl) {
                workPendingSubPriceInputEl.value = sub?.price_amount ?? "";
            }
            if (workPendingSubLimitInputEl) {
                workPendingSubLimitInputEl.value =
                    conn?.limit === null || conn?.limit === undefined ? "" : String(conn.limit);
            }
            renderPendingSubscriptionControls(sub);
        }

        async function loadPendingSubscriptionOverview(telegramIdRaw) {
            const telegramId = String(telegramIdRaw || "").trim();
            if (!telegramId) {
                renderPendingSubscriptionOverview(null);
                setPendingSubscriptionStatus("Укажи Telegram ID и сохрани параметры подписки.");
                return { ok: true, exists: false, overview: null };
            }
            if (!isValidTelegramId(telegramId)) {
                renderPendingSubscriptionOverview(null);
                setPendingSubscriptionStatus("Telegram ID должен содержать только цифры.", "error");
                return { ok: false, exists: false, overview: null };
            }

            const resp = await fetchJson(adminUserOverviewByTelegramUrl(telegramId), false);
            renderPendingSubscriptionOverview(resp?.overview || null);
            if (resp?.exists) {
                upsertWorkUserFromOverview(resp?.overview || null);
                const userId = resp?.overview?.user?.id;
                setPendingSubscriptionStatus(
                    userId ? `Пользователь #${userId} найден. Можно обновить подписку.` : "Пользователь найден."
                );
            } else {
                setPendingSubscriptionStatus("Пользователь будет создан автоматически при сохранении подписки.");
            }
            return resp;
        }

        function renderWorkSubExtendValue() {
            if (!workSubExtendRangeEl || !workSubExtendValueEl) return;
            const min = Number(workSubExtendRangeEl.min || 0);
            const max = Number(workSubExtendRangeEl.max || 100);
            const value = Number(workSubExtendRangeEl.value || min);
            const percent = max > min ? ((value - min) / (max - min)) * 100 : 0;
            workSubExtendRangeEl.style.setProperty("--work-sub-progress", `${percent}%`);
            workSubExtendValueEl.textContent = fmtMonthsText(value);
        }

        function renderWorkClientCards() {
            if (!workClientCardsEl) return;
            workClientCardsEl.innerHTML = "";

            if (!Array.isArray(workState.users) || !workState.users.length) {
                const empty = document.createElement("div");
                empty.className = "work-empty";
                empty.textContent = "Клиенты не найдены.";
                workClientCardsEl.appendChild(empty);
                return;
            }

            workState.users.forEach((user) => {
                const card = document.createElement("button");
                card.type = "button";
                card.className = "work-client-card";
                card.dataset.userId = String(user.id);

                const title = document.createElement("div");
                title.className = "work-client-card-title";
                title.textContent = user.name || user.username || `Клиент #${user.id}`;

                const sub = document.createElement("div");
                sub.className = "work-client-card-sub";
                sub.textContent = `${user.id} · ${user.username ? `@${user.username}` : "—"}`;

                card.appendChild(title);
                card.appendChild(sub);
                card.addEventListener("click", () => {
                    openWorkClientPage(user.id).catch((err) => {
                        console.error("open client error:", err);
                    });
                });
                workClientCardsEl.appendChild(card);
            });
        }

        function createWorkInboundStatusBadge(kind, enabled) {
            const isOn = Boolean(enabled);
            const badge = document.createElement("span");
            if (kind === "panel") {
                badge.className = `work-inbound-pill ${isOn ? "panel-on" : "panel-off"}`;
                badge.textContent = "🖥️";
                badge.title = isOn ? "Панель: on" : "Панель: off";
            } else {
                badge.className = `work-inbound-pill ${isOn ? "visibility-on" : "visibility-off"}`;
                badge.textContent = "👁️";
                badge.title = isOn ? "В приложении: видно" : "В приложении: скрыто";
            }
            badge.setAttribute("aria-label", badge.title);
            return badge;
        }

        function ensureWorkInboundOverlayMounted() {
            if (!workInboundOverlayEl) return;
            if (workInboundOverlayEl.parentElement !== document.body) {
                document.body.appendChild(workInboundOverlayEl);
            }
        }

        function closeWorkInboundOverlay() {
            if (!workInboundOverlayEl) return;
            workState.expandedInboundPanelId = null;
            workInboundOverlayEl.classList.add("hidden");
            workInboundOverlayEl.setAttribute("aria-hidden", "true");
            renderWorkInboundsManager();
        }

        function renderWorkInboundOverlay(panelIdRaw) {
            const panelId = Number(panelIdRaw || 0);
            if (!panelId) {
                closeWorkInboundOverlay();
                return;
            }

            const inbound = workState.inbounds.find((row) => String(row?.panel_inbound_id) === String(panelId));
            if (!inbound) {
                closeWorkInboundOverlay();
                return;
            }
            workState.expandedInboundPanelId = panelId;

            const panelEnabled = Boolean(inbound?.enable);
            const visibleForUsers = Boolean(inbound?.show_in_app);
            const titleText = String(inbound?.remark || `Inbound ${panelId}`).trim() || `Inbound ${panelId}`;
            const protocol = String(inbound?.protocol || "unknown").toLowerCase();

            if (workInboundOverlayTitleEl) {
                workInboundOverlayTitleEl.textContent = titleText;
                workInboundOverlayTitleEl.title = titleText;
            }
            if (workInboundOverlayMetaEl) {
                workInboundOverlayMetaEl.textContent = `#${panelId} • ${protocol} • порт: ${inbound?.port ?? "—"}`;
            }
            if (workInboundOverlayBadgesEl) {
                workInboundOverlayBadgesEl.innerHTML = "";
                workInboundOverlayBadgesEl.appendChild(createWorkInboundStatusBadge("panel", panelEnabled));
                workInboundOverlayBadgesEl.appendChild(createWorkInboundStatusBadge("visibility", visibleForUsers));
            }
            if (workInboundOverlayToggleBtnEl) {
                workInboundOverlayToggleBtnEl.textContent = visibleForUsers
                    ? "Скрыть у пользователей"
                    : "Показывать пользователям";
                workInboundOverlayToggleBtnEl.dataset.panelInboundId = String(panelId);
                workInboundOverlayToggleBtnEl.dataset.nextVisible = visibleForUsers ? "false" : "true";
            }
        }

        function openWorkInboundOverlay(panelIdRaw) {
            if (!workInboundOverlayEl) return;
            ensureWorkInboundOverlayMounted();
            renderWorkInboundOverlay(panelIdRaw);
            if (!workState.expandedInboundPanelId) return;
            workInboundOverlayEl.classList.remove("hidden");
            workInboundOverlayEl.setAttribute("aria-hidden", "false");
            renderWorkInboundsManager();
        }

        async function toggleWorkInboundVisibility(panelIdRaw, nextVisibleRaw) {
            const panelId = Number(panelIdRaw || 0);
            if (!panelId) return;
            const nextVisible = String(nextVisibleRaw) === "true";

            await runWorkAction("Toggle Inbound Visibility", async () => {
                const result = await postJson(adminInboundVisibilityUrl(panelId), {
                    show_in_app: nextVisible,
                });
                const updated = result?.inbound || null;
                if (updated) {
                    workState.inbounds = workState.inbounds.map((row) =>
                        String(row?.panel_inbound_id) === String(updated.panel_inbound_id)
                            ? { ...row, ...updated }
                            : row
                    );
                } else {
                    await loadWorkClientsData();
                }

                renderWorkInboundsManager();
                renderWorkInboundSelectOptions();
                renderWorkPendingInboundSelectOptions();
                if (workState.expandedInboundPanelId) {
                    renderWorkInboundOverlay(workState.expandedInboundPanelId);
                }
                return result;
            });
        }

        function renderWorkInboundsManager() {
            if (!workInboundsListEl) return;
            workInboundsListEl.innerHTML = "";

            const rows = Array.isArray(workState.inbounds) ? workState.inbounds : [];
            if (!rows.length) {
                const empty = document.createElement("div");
                empty.className = "work-empty";
                empty.textContent = "Подключения не найдены. Нажми «Синхр.»";
                workInboundsListEl.appendChild(empty);
                return;
            }

            rows.forEach((inbound) => {
                const panelId = Number(inbound?.panel_inbound_id || 0);
                const panelEnabled = Boolean(inbound?.enable);
                const visibleForUsers = Boolean(inbound?.show_in_app);

                const card = document.createElement("div");
                const isExpanded = String(workState.expandedInboundPanelId) === String(panelId);
                card.className = `work-inbound-card interactive${isExpanded ? " active" : ""}`;
                card.tabIndex = 0;
                card.setAttribute("role", "button");
                card.setAttribute("aria-label", `Развернуть подключение ${panelId}`);

                const head = document.createElement("div");
                head.className = "work-inbound-head";

                const title = document.createElement("div");
                title.className = "work-inbound-title";
                title.textContent = String(inbound?.remark || `Inbound ${panelId}`).trim() || `Inbound ${panelId}`;

                const badges = document.createElement("div");
                badges.className = "work-inbound-badges";

                const panelBadge = createWorkInboundStatusBadge("panel", panelEnabled);
                const visibilityBadge = createWorkInboundStatusBadge("visibility", visibleForUsers);
                const expandHint = document.createElement("div");
                expandHint.className = "work-inbound-expand-hint";
                expandHint.textContent = "⤢";
                expandHint.title = "Развернуть";

                badges.appendChild(panelBadge);
                badges.appendChild(visibilityBadge);
                head.appendChild(title);
                head.appendChild(badges);
                head.appendChild(expandHint);

                const meta = document.createElement("div");
                meta.className = "work-inbound-meta";
                const protocol = String(inbound?.protocol || "unknown").toLowerCase();
                meta.textContent = `#${panelId} • ${protocol} • порт: ${inbound?.port ?? "—"}`;

                const openOverlay = () => {
                    openWorkInboundOverlay(panelId);
                };
                card.addEventListener("click", openOverlay);
                card.addEventListener("keydown", (event) => {
                    if (event.key !== "Enter" && event.key !== " ") return;
                    event.preventDefault();
                    openOverlay();
                });

                card.appendChild(head);
                card.appendChild(meta);
                workInboundsListEl.appendChild(card);
            });
        }

        function parseBoolValue(value, fallback = true) {
            if (typeof value === "boolean") return value;
            if (typeof value === "number") return value !== 0;
            if (typeof value === "string") {
                const normalized = value.trim().toLowerCase();
                if (["1", "true", "yes", "on"].includes(normalized)) return true;
                if (["0", "false", "no", "off"].includes(normalized)) return false;
            }
            return fallback;
        }

        function parseIntInRange(value, fallback, minValue, maxValue) {
            const parsed = Number.parseInt(String(value ?? "").trim(), 10);
            let out = Number.isInteger(parsed) ? parsed : fallback;
            if (typeof minValue === "number") out = Math.max(minValue, out);
            if (typeof maxValue === "number") out = Math.min(maxValue, out);
            return out;
        }

        function setWorkSettingsStatus(message, tone = "") {
            if (!workSettingsSaveStatusEl) return;
            workSettingsSaveStatusEl.classList.remove("success", "error");
            if (!message) {
                workSettingsSaveStatusEl.textContent = "";
                workSettingsSaveStatusEl.classList.add("hidden");
                return;
            }
            if (tone === "success" || tone === "error") {
                workSettingsSaveStatusEl.classList.add(tone);
            }
            workSettingsSaveStatusEl.textContent = message;
            workSettingsSaveStatusEl.classList.remove("hidden");
        }

        function applyWorkSettingsFormValues(settingsMap) {
            const cloudVisible = parseBoolValue(settingsMap?.[systemSettingKeys.cloudVisibility], true);
            const chunkSizeMb = parseIntInRange(settingsMap?.[systemSettingKeys.cloudChunkSizeMb], 15, 1, 20);
            const sendTimeoutSec = parseIntInRange(settingsMap?.[systemSettingKeys.cloudSendTimeoutSec], 300, 30, 1800);
            const sendRetries = parseIntInRange(settingsMap?.[systemSettingKeys.cloudSendRetries], 3, 1, 10);
            const sendRetryDelaySec = parseIntInRange(settingsMap?.[systemSettingKeys.cloudSendRetryDelaySec], 2, 1, 60);

            if (workSettingCloudVisibilityEl) {
                workSettingCloudVisibilityEl.value = cloudVisible ? "true" : "false";
            }
            if (workSettingCloudChunkMbEl) {
                workSettingCloudChunkMbEl.value = String(chunkSizeMb);
            }
            if (workSettingCloudSendTimeoutEl) {
                workSettingCloudSendTimeoutEl.value = String(sendTimeoutSec);
            }
            if (workSettingCloudSendRetriesEl) {
                workSettingCloudSendRetriesEl.value = String(sendRetries);
            }
            if (workSettingCloudSendRetryDelayEl) {
                workSettingCloudSendRetryDelayEl.value = String(sendRetryDelaySec);
            }
        }

        async function loadWorkSystemSettings() {
            setWorkSettingsStatus("", "");
            const resp = await fetchJson(`${adminSettingsUrl}?prefix=cloud.`, false);
            const rows = Array.isArray(resp?.settings) ? resp.settings : [];
            const settingsMap = {};
            rows.forEach((row) => {
                const key = String(row?.key || "").trim();
                if (!key) return;
                settingsMap[key] = row?.value;
            });
            workState.settings = settingsMap;
            applyWorkSettingsFormValues(settingsMap);
            return settingsMap;
        }

        async function saveWorkSystemSettings() {
            const cloudVisible = workSettingCloudVisibilityEl?.value !== "false";
            const chunkSizeMb = parseIntInRange(workSettingCloudChunkMbEl?.value, 15, 1, 20);
            const sendTimeoutSec = parseIntInRange(workSettingCloudSendTimeoutEl?.value, 300, 30, 1800);
            const sendRetries = parseIntInRange(workSettingCloudSendRetriesEl?.value, 3, 1, 10);
            const sendRetryDelaySec = parseIntInRange(workSettingCloudSendRetryDelayEl?.value, 2, 1, 60);

            const payloads = [
                {
                    key: systemSettingKeys.cloudVisibility,
                    value: cloudVisible,
                    description: "Show or hide Cloud section in app",
                },
                {
                    key: systemSettingKeys.cloudChunkSizeMb,
                    value: chunkSizeMb,
                    description: "Cloud upload chunk size in megabytes",
                },
                {
                    key: systemSettingKeys.cloudSendTimeoutSec,
                    value: sendTimeoutSec,
                    description: "Telegram send timeout in seconds",
                },
                {
                    key: systemSettingKeys.cloudSendRetries,
                    value: sendRetries,
                    description: "Telegram send retry attempts",
                },
                {
                    key: systemSettingKeys.cloudSendRetryDelaySec,
                    value: sendRetryDelaySec,
                    description: "Telegram send retry delay in seconds",
                },
            ];

            for (const item of payloads) {
                await postJson(adminSettingUrl(item.key), {
                    value: item.value,
                    description: item.description,
                });
            }

            await loadWorkSystemSettings();
            applyCloudVisibility({ features: { cloud_enabled: cloudVisible } });
            return payloads;
        }

        function renderExistingBindings(bindings) {
            if (!workExistingLinksEl) return;
            workExistingLinksEl.innerHTML = "";

            if (!Array.isArray(bindings) || !bindings.length) {
                const empty = document.createElement("div");
                empty.className = "work-empty";
                empty.textContent = "Связей пока нет.";
                workExistingLinksEl.appendChild(empty);
                return;
            }

            const groups = new Map();
            bindings.forEach((binding) => {
                const inboundId = binding.panel_inbound_id ?? "—";
                const connectionName = (binding.inbound_remark || "").trim() || `Inbound ${inboundId}`;
                const key = `${inboundId}::${connectionName}`;
                if (!groups.has(key)) {
                    groups.set(key, {
                        connectionName,
                        clients: [],
                        statuses: [],
                        latestUpdated: null,
                    });
                }
                const group = groups.get(key);
                const label = String(binding.label || binding.identifier || "—").trim() || "—";
                const status = String(binding.status || "—").trim() || "—";
                group.clients.push({
                    id: binding.id,
                    label,
                });
                if (!group.statuses.includes(status)) group.statuses.push(status);

                const updated = binding.updated_at ? new Date(binding.updated_at) : null;
                if (updated && !Number.isNaN(updated.getTime())) {
                    if (!group.latestUpdated || updated > group.latestUpdated) {
                        group.latestUpdated = updated;
                    }
                }
            });

            groups.forEach((group) => {
                const item = document.createElement("div");
                item.className = "work-link-item";

                const title = document.createElement("div");
                title.className = "work-link-item-title";
                title.textContent = group.connectionName;

                const statusLine = document.createElement("div");
                statusLine.className = "work-link-item-sub";
                statusLine.textContent = `status: ${group.statuses.join(" • ") || "—"}`;

                const updatedLine = document.createElement("div");
                updatedLine.className = "work-link-item-sub";
                updatedLine.textContent = `обновлено: ${group.latestUpdated ? fmtDateTime(group.latestUpdated.toISOString()) : "—"}`;

                const clientsWrap = document.createElement("div");
                clientsWrap.className = "work-link-clients";
                group.clients.forEach((client) => {
                    const row = document.createElement("div");
                    row.className = "work-link-client";

                    const name = document.createElement("div");
                    name.className = "work-link-client-name";
                    name.textContent = client.label;

                    const removeBtn = document.createElement("button");
                    removeBtn.type = "button";
                    removeBtn.className = "work-link-client-remove";
                    removeBtn.textContent = "Удалить";
                    removeBtn.addEventListener("click", async (event) => {
                        event.stopPropagation();
                        await runWorkAction("Delete Binding", async () => {
                            await postJson(adminUnbindClientUrl, { binding_id: client.id });
                            await loadSelectedUserBindings();
                            await loadSelectedUserOverview();
                            return { deleted: client.id };
                        });
                    });

                    row.appendChild(name);
                    row.appendChild(removeBtn);
                    clientsWrap.appendChild(row);
                });

                item.appendChild(title);
                item.appendChild(statusLine);
                item.appendChild(updatedLine);
                item.appendChild(clientsWrap);
                workExistingLinksEl.appendChild(item);
            });
        }

        function resolveInboundClientSelection(inboundSelectEl, clientSelectEl, clients, emptyMessage) {
            const panelInboundId = inboundSelectEl?.value;
            const clientIndex = clientSelectEl?.value;
            if (!panelInboundId || clientIndex === "") {
                throw new Error(emptyMessage || "Выбери inbound и клиента");
            }

            const inbound = workState.inbounds.find((i) => String(i.panel_inbound_id) === String(panelInboundId));
            const client = Array.isArray(clients) ? clients[Number(clientIndex)] : null;
            if (!client || !inbound) {
                throw new Error("Данные inbound/client не найдены");
            }
            return { panelInboundId: Number(panelInboundId), inbound, client };
        }

        function renderPendingBindings(rows) {
            if (!workPendingListEl) return;
            workPendingListEl.innerHTML = "";

            if (!Array.isArray(rows) || !rows.length) {
                const empty = document.createElement("div");
                empty.className = "work-empty";
                empty.textContent = "Pending-привязок пока нет.";
                workPendingListEl.appendChild(empty);
                return;
            }

            rows.forEach((row) => {
                const item = document.createElement("div");
                item.className = "work-link-item";

                const title = document.createElement("div");
                title.className = "work-link-item-title";
                title.textContent = row?.inbound_remark || row?.label || row?.identifier || `Inbound ${row?.panel_inbound_id ?? "—"}`;

                const line1 = document.createElement("div");
                line1.className = "work-link-item-sub";
                line1.textContent = `TG: ${row?.telegram_id || "—"} • client: ${row?.label || row?.identifier || "—"}`;

                const line2 = document.createElement("div");
                line2.className = "work-link-item-sub";
                line2.textContent = `status: ${row?.status || "—"} • protocol: ${row?.protocol || "—"}`;

                item.appendChild(title);
                item.appendChild(line1);
                item.appendChild(line2);

                if (String(row?.status || "").toLowerCase() === "pending") {
                    const rowActions = document.createElement("div");
                    rowActions.className = "work-link-clients";

                    const rowActionWrap = document.createElement("div");
                    rowActionWrap.className = "work-link-client";

                    const rowActionName = document.createElement("div");
                    rowActionName.className = "work-link-client-name";
                    rowActionName.textContent = "Ожидает первого входа";

                    const cancelBtn = document.createElement("button");
                    cancelBtn.type = "button";
                    cancelBtn.className = "work-link-client-remove";
                    cancelBtn.textContent = "Отменить";
                    cancelBtn.addEventListener("click", async (event) => {
                        event.stopPropagation();
                        await runWorkAction("Cancel Pending Binding", async () => {
                            await postJson(adminCancelPendingBindingUrl(row.id));
                            await loadPendingBindings(workPendingTelegramIdEl?.value);
                            return { canceled: row.id };
                        });
                    });

                    rowActionWrap.appendChild(rowActionName);
                    rowActionWrap.appendChild(cancelBtn);
                    rowActions.appendChild(rowActionWrap);
                    item.appendChild(rowActions);
                }

                workPendingListEl.appendChild(item);
            });
        }

        async function loadPendingBindings(telegramIdRaw) {
            const telegramId = String(telegramIdRaw || "").trim();
            if (!telegramId) {
                workState.pendingBindings = [];
                renderPendingBindings([]);
                return { ok: true, pending_bindings: [] };
            }
            const url = `${adminPendingBindingsUrl}?telegram_id=${encodeURIComponent(telegramId)}&limit=200`;
            const resp = await fetchJson(url, false);
            workState.pendingBindings = Array.isArray(resp?.pending_bindings) ? resp.pending_bindings : [];
            renderPendingBindings(workState.pendingBindings);
            return resp;
        }

        function renderWorkClientOverview(overview) {
            workState.overview = overview || null;
            const sub = overview?.subscription || null;
            const conn = overview?.connections || null;
            renderWorkSubscriptionControls(sub);

            workClientSubStatusEl.textContent = sub?.status || "нет";
            workClientSubUntilEl.textContent = formatSubscriptionUntil(sub, fmtDateTime);
            workClientSubPriceEl.textContent = fmtMoney(sub?.price_amount);

            if (!conn) {
                workClientConnectionsAvailableEl.textContent = "—";
            } else if (conn.limit === null || conn.limit === undefined) {
                workClientConnectionsAvailableEl.textContent = `${conn.active ?? 0}/∞`;
            } else {
                workClientConnectionsAvailableEl.textContent = `${conn.active ?? 0}/${conn.limit}`;
            }

            if (workSubStatusSelectEl) {
                workSubStatusSelectEl.value = sub?.status || "active";
            }
            if (workSubPriceInputEl) {
                workSubPriceInputEl.value = sub?.price_amount ?? "";
            }
            if (workSubLimitInputEl) {
                workSubLimitInputEl.value =
                    conn?.limit === null || conn?.limit === undefined ? "" : String(conn.limit);
            }
        }

        async function loadSelectedUserOverview() {
            if (!workState.selectedUserId) {
                renderWorkClientOverview(null);
                return { ok: true, overview: null };
            }
            const resp = await fetchJson(adminUserOverviewUrl(workState.selectedUserId), false);
            renderWorkClientOverview(resp?.overview || null);
            return resp;
        }

        function setSelectedWorkClient(user) {
            if (!user) {
                workClientPageTitleEl.textContent = "Клиент";
                workClientPageTitleEl.title = "Клиент";
                if (getActiveWorkPageId() === "work-client-page") {
                    updateWorkPageContext("work-client-page");
                }
                workClientNameEl.textContent = "—";
                workClientMetaEl.textContent = "—";
                renderWorkClientOverview(null);
                return;
            }
            const title = user.name || user.username || `Клиент #${user.id}`;
            workClientPageTitleEl.textContent = title;
            workClientPageTitleEl.title = title;
            if (getActiveWorkPageId() === "work-client-page") {
                updateWorkPageContext("work-client-page");
            }
            workClientNameEl.textContent = title;
            workClientMetaEl.textContent = `${user.id} · ${user.username ? `@${user.username}` : "—"}`;
        }

        async function loadWorkClientsData() {
            const [usersResp, inboundsResp] = await Promise.all([
                fetchJson(adminUsersUrl, false),
                fetchJson(adminInboundsUrl, false),
            ]);
            workState.users = Array.isArray(usersResp?.users) ? usersResp.users : [];
            workState.inbounds = Array.isArray(inboundsResp?.inbounds) ? inboundsResp.inbounds : [];
            renderWorkClientCards();
            renderWorkInboundsManager();
            renderWorkInboundSelectOptions();
            renderWorkPendingInboundSelectOptions();
            fillSelect(
                workClientSelectEl,
                [],
                () => "",
                () => "",
                "Select client from inbound"
            );
            fillSelect(
                workPendingClientSelectEl,
                [],
                () => "",
                () => "",
                "Select client from inbound"
            );
            workState.clients = [];
            workState.pendingClients = [];
            if (workPendingInboundSelectEl?.value) {
                await loadPendingInboundClients(workPendingInboundSelectEl.value);
            }
            const pendingTgId = workPendingTelegramIdEl?.value?.trim();
            if (pendingTgId) {
                await Promise.all([loadPendingBindings(pendingTgId), loadPendingSubscriptionOverview(pendingTgId)]);
            } else {
                workState.pendingBindings = [];
                renderPendingBindings([]);
                renderPendingSubscriptionOverview(null);
                setPendingSubscriptionStatus("Укажи Telegram ID и сохрани параметры подписки.");
            }
            return { users: workState.users.length, inbounds: workState.inbounds.length };
        }

        async function loadSelectedUserBindings() {
            if (!workState.selectedUserId) {
                workState.bindings = [];
                renderExistingBindings([]);
                return { bindings: 0 };
            }
            const resp = await fetchJson(adminUserBindingsUrl(workState.selectedUserId), false);
            workState.bindings = Array.isArray(resp?.bindings) ? resp.bindings : [];
            renderExistingBindings(workState.bindings);
            return { bindings: workState.bindings.length };
        }

        async function openWorkClientPage(userId) {
            const user = workState.users.find((u) => String(u.id) === String(userId));
            if (!user) {
                throw new Error("Клиент не найден");
            }

            workState.selectedUserId = user.id;
            setSelectedWorkClient(user);
            if (workPendingTelegramIdEl) {
                workPendingTelegramIdEl.value = user?.telegram_id ? String(user.telegram_id) : "";
            }
            if (workSubCreateDateEl) {
                workSubCreateDateEl.value = "";
            }
            switchWorkPage("work-client-page");

            fillSelect(
                workClientSelectEl,
                [],
                () => "",
                () => "",
                "Выбери клиента из inbound"
            );
            workState.clients = [];
            if (workInboundSelectEl?.value) {
                await loadInboundClients(workInboundSelectEl.value);
            }
            const pendingTgId = workPendingTelegramIdEl?.value?.trim();
            await Promise.all([
                loadSelectedUserBindings(),
                loadSelectedUserOverview(),
                pendingTgId ? loadPendingBindings(pendingTgId) : Promise.resolve(),
                pendingTgId ? loadPendingSubscriptionOverview(pendingTgId) : Promise.resolve(),
            ]);
        }

        async function loadInboundClients(panelInboundId) {
            if (!panelInboundId) {
                workState.clients = [];
                fillSelect(workClientSelectEl, [], () => "", () => "", "Выбери клиента из inbound");
                return;
            }
            const resp = await fetchJson(`${window.location.origin}/api/admin/inbounds/${panelInboundId}/clients`, false);
            workState.clients = Array.isArray(resp?.clients) ? resp.clients : [];
            fillSelect(
                workClientSelectEl,
                workState.clients,
                (c, idx) => `${idx + 1}. ${c.label || "Клиент"}`,
                (_, idx) => String(idx),
                "Выбери клиента из inbound"
            );
        }

        async function refreshInboundClientsFromPanel() {
            const panelInboundId = workInboundSelectEl?.value?.trim();
            if (!panelInboundId) {
                throw new Error("Сначала выбери inbound");
            }

            await postJson(adminSyncInboundsUrl);
            const inboundsResp = await fetchJson(adminInboundsUrl, false);
            workState.inbounds = Array.isArray(inboundsResp?.inbounds) ? inboundsResp.inbounds : [];
            renderWorkInboundsManager();
            renderWorkInboundSelectOptions();
            renderWorkPendingInboundSelectOptions();

            const exists = workState.inbounds.some((row) => String(row?.panel_inbound_id) === panelInboundId);
            if (!exists) {
                workState.clients = [];
                fillSelect(workClientSelectEl, [], () => "", () => "", "Выбери клиента из inbound");
                throw new Error(`Inbound ${panelInboundId} не найден после обновления`);
            }

            if (workInboundSelectEl) {
                workInboundSelectEl.value = panelInboundId;
            }
            await loadInboundClients(panelInboundId);
            if (workPendingInboundSelectEl?.value === panelInboundId) {
                await loadPendingInboundClients(panelInboundId);
            }

            return { inbounds: workState.inbounds.length, clients: workState.clients.length };
        }


        async function loadPendingInboundClients(panelInboundId) {
            if (!panelInboundId) {
                workState.pendingClients = [];
                fillSelect(workPendingClientSelectEl, [], () => "", () => "", "Select client from inbound");
                return;
            }
            const resp = await fetchJson(`${window.location.origin}/api/admin/inbounds/${panelInboundId}/clients`, false);
            workState.pendingClients = Array.isArray(resp?.clients) ? resp.clients : [];
            fillSelect(
                workPendingClientSelectEl,
                workState.pendingClients,
                (c, idx) => `${idx + 1}. ${c.label || "Client"}`,
                (_, idx) => String(idx),
                "Select client from inbound"
            );
        }

        function switchWorkPage(target) {
            const next = target || "work-menu-page";
            if (next !== "work-inbounds-page") {
                closeWorkInboundOverlay();
            }
            workPages.forEach((page) => page.classList.toggle("hidden", page.id !== next));
            const hideWorkHeaders = next !== "work-menu-page";
            setTopbarVisibility(hideWorkHeaders);
            workSectionTitleEl?.classList.toggle("hidden", hideWorkHeaders);
            updateWorkPageContext(next);
            updateScreenMenuContext("screen-work");
            updateTelegramBackButton();
            if (next === "work-system-settings-page") {
                loadWorkSystemSettings().catch((err) => {
                    console.error("load system settings error:", err);
                    setWorkSettingsStatus(err?.message || "Не удалось загрузить настройки", "error");
                });
            }
        }

        function switchScreen(target) {
            const previousScreen = getActiveScreenId();
            if (target === "screen-cloud" && !uiFeatures.cloudEnabled) {
                target = "screen-home";
            }
            heroCardEl?.classList.toggle("hidden", target !== "screen-home");
            navButtons.forEach((b) => b.classList.toggle("active", b.dataset.screen === target));
            screens.forEach((s) => s.classList.toggle("hidden", s.id !== target));
            if (target !== "screen-work") {
                setTopbarVisibility(false);
                workSectionTitleEl?.classList.remove("hidden");
            }
            if (target === "screen-work") {
                switchWorkPage("work-menu-page");
            }
            if (target !== "screen-connections") {
                openConnectionsMenu();
            }
            if (target !== "screen-cloud") {
                closeCloudPreview();
            }
            if (target !== "screen-work") {
                closeWorkInboundOverlay();
            }
            if (target === "screen-cloud") {
                if (previousScreen !== "screen-cloud") {
                    cloudState.path = "/";
                }
                ensureCloudLoaded(true).catch((err) => {
                    console.error("cloud init error:", err);
                    setCloudStatus(err?.message || "Не удалось загрузить облако", "error");
                });
            }
            updateScreenMenuContext(target);
            updateTelegramBackButton();
            updateCloudUpButton();
        }

        async function runWorkAction(title, action) {
            try {
                await action();
            } catch (err) {
                console.error(`${title} ERROR:`, err);
            }
        }

        async function loadRuntimeData() {
            if (DEV_MODE) {
                return {
                    me: {
                        ok: true,
                        user: { telegram_id: "999000111", role: "admin", name: "Dev Mode" },
                        subscription: { status: "active", access_until: new Date(Date.now() + 86400000 * 30).toISOString() },
                        features: { cloud_enabled: true },
                    },
                    status: {
                        ok: true,
                        services: {
                            vless: { ok: true, visible_in_app: true },
                            http: { ok: true, visible_in_app: true },
                            mixed: { ok: true, visible_in_app: true },
                            https_mixed: { ok: true, visible_in_app: true },
                        },
                    },
                    vless: {
                        ok: true,
                        host: "dev.local",
                        port: 443,
                        vless_url: "vless://demo",
                        connections: [
                            { label: "Dev-VLESS-1", host: "dev.local", port: 443, vless_url: "vless://demo1" },
                            { label: "Dev-VLESS-2", host: "dev.local", port: 443, vless_url: "vless://demo2" },
                        ],
                    },
                    http: {
                        ok: true,
                        host: "dev.local",
                        port: 8080,
                        urls: ["http://demo"],
                        connections: [
                            { label: "Dev-HTTP-1", host: "dev.local", port: 8080, urls: ["http://demo-http-1"] },
                        ],
                    },
                    mixed: {
                        ok: true,
                        host: "dev.local",
                        port: 8443,
                        username: "DEV_USER",
                        password: "DEV_PASS",
                        urls: ["socks5://demo"],
                        connections: [
                            { label: "Dev-Mixed-1", host: "dev.local", port: 8443, username: "CAR011NA", password: "yLO06l4AFM", urls: ["socks5://demo1", "http://demo1"] },
                            { label: "Dev-Mixed-2", host: "dev.local", port: 8443, username: "BYTEARC", password: "pass_2", urls: ["socks5://demo2", "http://demo2"] },
                        ],
                    },
                };
            }

            const [me, status, vless, http, mixed] = await Promise.all([
                fetchJson(meUrl, false),
                fetchJson(statusUrl, false),
                fetchJson(vpnConfigUrl, true),
                fetchJson(vpnHttpUrl, true),
                fetchJson(vpnMixedUrl, true),
            ]);
            return { me, status, vless, http, mixed };
        }

        const statusSteps = [
            { text: "Проверяем сервер…", glow: "rgba(55, 224, 255, 0.55)" },
            { text: "Загружаем подключения…", glow: "rgba(79, 123, 255, 0.55)" },
            { text: "Готовим данные…", glow: "rgba(168, 85, 247, 0.55)" },
        ];
        let statusIndex = 0;

        function cycleStatus() {
            statusLabel.classList.add("fade-out");
            setTimeout(() => {
                statusIndex = (statusIndex + 1) % statusSteps.length;
                const step = statusSteps[statusIndex];
                statusLabel.textContent = step.text;
                pulseScene?.style.setProperty("--glow-color", step.glow);
                statusLabel.classList.remove("fade-out");
            }, 160);
        }

        const CYCLE_MS = 4800; // удлинённый цикл для тестов (было 2400)
        setInterval(cycleStatus, CYCLE_MS);
        pulseScene?.style.setProperty("--glow-color", statusSteps[0].glow);

        async function validateUser() {
            if (DEV_MODE) {
                const fakeUser = {
                    id: 0,
                    username: "dev_user",
                    first_name: "Dev",
                    last_name: "Mode",
                };
                return { ok: true, user: fakeUser };
            }

            const initData = window.Telegram?.WebApp?.initData;
            console.log("initData present:", Boolean(initData));
            if (!initData) {
                throw new Error("Не обнаружены данные Telegram Web App. Запустите мини‑приложение через Telegram.");
            }

            console.log("sending /api/tg/auth");
            const response = await fetch(authUrl, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                credentials: "same-origin",
                body: JSON.stringify({ initData }),
            });

            let payload;
            try {
                payload = await response.json();
            } catch (e) {
                const raw = await response.text();
                console.error("Auth raw response:", raw);
                throw new Error("Сервер вернул не-JSON: " + raw.slice(0, 120));
            }

            if (!response.ok || !payload.ok) {
                throw new Error(payload.error || "Телеграм не подтвердил данные пользователя.");
            }

            csrfToken = typeof payload?.csrf_token === "string" ? payload.csrf_token : "";
            if (!csrfToken) {
                throw new Error("Сервер не вернул CSRF token.");
            }
            return payload;
        }

        async function init() {
            console.log("Init start");
            try {
                window.Telegram?.WebApp?.ready?.();
                ensureSafeViewportMode();
                syncBackNavigationMode();
                setTopbarVisibility(false);
                await loadNavSecondPreference();
                await loadVlessGuidePreference();
                const payload = await validateUser();
                console.log("Auth ok", payload.user);
                const runtime = await loadRuntimeData();
                renderDashboard(runtime);
                const delay = payload?.show_long_intro ? 2400 : 400;
                await wait(delay);
                await showApp(payload.user?.first_name || payload.user?.username);
            } catch (err) {
                console.error("Auth failed", err);
                showError(err.message);
            } finally {
                // страхуемся от зависания лоадера
                loading.classList.add("hidden");
                mainEl.classList.remove("hidden");
            }
        }

        if (document.readyState === "loading") {
            window.addEventListener("DOMContentLoaded", init);
        } else {
            init();
        }

        // bottom nav (простое переключение экранов)
        navButtons.forEach((btn) =>
            btn.addEventListener("click", () => {
                switchScreen(btn.dataset.screen);
            })
        );
        settingsNavSecondSelectEl?.addEventListener("change", () => {
            const nextValue = normalizeNavSecondItemKey(settingsNavSecondSelectEl.value);
            saveNavSecondPreference(nextValue).catch((err) => {
                console.error("save nav second preference error:", err);
            });
        });
        screenMenuContextPillEl?.addEventListener("click", () => {
            runScreenMenuContextAction().catch((err) => {
                console.error("screen menu context action click error:", err);
            });
        });
        screenMenuContextPillEl?.addEventListener("keydown", (event) => {
            if (event.key !== "Enter" && event.key !== " ") return;
            event.preventDefault();
            runScreenMenuContextAction().catch((err) => {
                console.error("screen menu context action key error:", err);
            });
        });
        workPageContextPillEl?.addEventListener("click", () => {
            runWorkPageContextAction().catch((err) => {
                console.error("work page context action click error:", err);
            });
        });
        workPageContextPillEl?.addEventListener("keydown", (event) => {
            if (event.key !== "Enter" && event.key !== " ") return;
            event.preventDefault();
            runWorkPageContextAction().catch((err) => {
                console.error("work page context action key error:", err);
            });
        });

        connectionProtocolButtons.forEach((btn) =>
            btn.addEventListener("click", () => {
                const protocol = btn.dataset.connectionProtocol;
                if (!protocol) return;
                openConnectionsDetail(protocol);
            })
        );

        connectionsBackBtnEl?.addEventListener("click", () => {
            openConnectionsMenu();
        });

        cloudUpBtnEl?.addEventListener("click", () => {
            loadCloudPath(cloudParentPath(cloudState.path)).catch((err) => {
                console.error("cloud up error:", err);
                setCloudStatus(err.message || "Не удалось открыть родительскую папку", "error");
            });
        });

        cloudNewFolderBtnEl?.addEventListener("click", async () => {
            await createCloudFolder();
        });

        cloudUploadInputEl?.addEventListener("change", async () => {
            const files = cloudUploadInputEl?.files;
            if (!files || !files.length) return;
            try {
                await uploadCloudFiles(files);
            } finally {
                cloudUploadInputEl.value = "";
            }
        });

        cloudPreviewCloseBtnEl?.addEventListener("click", () => {
            closeCloudPreview();
        });
        workInboundOverlayCloseBtnEl?.addEventListener("click", () => {
            closeWorkInboundOverlay();
        });
        workInboundOverlayToggleBtnEl?.addEventListener("click", async () => {
            const panelId = workInboundOverlayToggleBtnEl.dataset.panelInboundId;
            const nextVisible = workInboundOverlayToggleBtnEl.dataset.nextVisible;
            await toggleWorkInboundVisibility(panelId, nextVisible);
        });
        workInboundOverlayCardEl?.addEventListener("click", (event) => {
            event.stopPropagation();
        });
        workInboundOverlayEl?.addEventListener("click", (event) => {
            if (event.target === workInboundOverlayEl) {
                closeWorkInboundOverlay();
            }
        });
        vlessGuideHideBtnEl?.addEventListener("click", () => {
            closeVlessGuide();
        });
        vlessGuideHideCheckboxEl?.addEventListener("change", async () => {
            try {
                await saveVlessGuidePreference(Boolean(vlessGuideHideCheckboxEl.checked));
            } catch (err) {
                console.error("save vless guide preference error:", err);
            }
        });
        vlessGuideCardEl?.addEventListener("click", (event) => {
            event.stopPropagation();
        });
        vlessGuideOverlayEl?.addEventListener("click", (event) => {
            if (event.target === vlessGuideOverlayEl) {
                closeVlessGuide();
            }
        });
        cloudPreviewCardEl?.addEventListener("click", (event) => {
            event.stopPropagation();
        });
        cloudPreviewOverlayEl?.addEventListener("click", (event) => {
            if (event.target === cloudPreviewOverlayEl) {
                closeCloudPreview();
            }
        });
        document.addEventListener("keydown", (event) => {
            if (event.key !== "Escape") return;
            if (workInboundOverlayEl && !workInboundOverlayEl.classList.contains("hidden")) {
                closeWorkInboundOverlay();
                return;
            }
            if (cloudPreviewOverlayEl && !cloudPreviewOverlayEl.classList.contains("hidden")) {
                closeCloudPreview();
                return;
            }
            if (vlessGuideOverlayEl && !vlessGuideOverlayEl.classList.contains("hidden")) {
                closeVlessGuide();
            }
        });

        workNavButtons.forEach((btn) =>
            btn.addEventListener("click", () => {
                switchWorkPage(btn.dataset.workNav || "work-menu-page");
            })
        );

        workBackButtons.forEach((btn) =>
            btn.addEventListener("click", () => {
                switchWorkPage(btn.dataset.workBack || "work-menu-page");
            })
        );

        profileIdToggleEl?.addEventListener("click", () => {
            showFullTelegramId = !showFullTelegramId;
            renderTelegramId();
        });

        workSettingsRefreshBtnEl?.addEventListener("click", async () => {
            try {
                await loadWorkSystemSettings();
                setWorkSettingsStatus("Настройки обновлены", "success");
            } catch (err) {
                console.error("refresh system settings error:", err);
                setWorkSettingsStatus(err?.message || "Не удалось обновить настройки", "error");
            }
        });

        workSettingsSaveBtnEl?.addEventListener("click", async () => {
            try {
                await saveWorkSystemSettings();
                setWorkSettingsStatus("Настройки сохранены", "success");
            } catch (err) {
                console.error("save system settings error:", err);
                setWorkSettingsStatus(err?.message || "Не удалось сохранить настройки", "error");
            }
        });

        workRefreshInboundClientsBtnEl?.addEventListener("click", async () => {
            await runWorkAction("Refresh Inbound Clients", async () => {
                return refreshInboundClientsFromPanel();
            });
        });

        workInboundSelectEl?.addEventListener("change", async () => {
            workState.clients = [];
            fillSelect(workClientSelectEl, [], () => "", () => "", "Select client from inbound");
            if (!workInboundSelectEl?.value) {
                return;
            }
            try {
                await loadInboundClients(workInboundSelectEl.value);
            } catch (err) {
                console.error("load inbound clients error:", err);
            }
        });

        workPendingInboundSelectEl?.addEventListener("change", async () => {
            workState.pendingClients = [];
            fillSelect(workPendingClientSelectEl, [], () => "", () => "", "Select client from inbound");
            if (!workPendingInboundSelectEl?.value) {
                return;
            }
            try {
                await loadPendingInboundClients(workPendingInboundSelectEl.value);
            } catch (err) {
                console.error("load pending inbound clients error:", err);
            }
        });

        workPendingTelegramIdEl?.addEventListener("change", async () => {
            try {
                await Promise.all([
                    loadPendingBindings(workPendingTelegramIdEl.value),
                    loadPendingSubscriptionOverview(workPendingTelegramIdEl.value),
                ]);
            } catch (err) {
                console.error("load pending data error:", err);
            }
        });

        workPendingSubStatusSelectEl?.addEventListener("change", () => {
            renderPendingSubscriptionControls(workState.pendingOverview?.subscription || null, { preserveDate: true });
        });

        workPendingSubSaveBtnEl?.addEventListener("click", async () => {
            await runWorkAction("Save Pending Subscription", async () => {
                const telegramId = String(workPendingTelegramIdEl?.value || "").trim();
                if (!isValidTelegramId(telegramId)) {
                    setPendingSubscriptionStatus("Укажи корректный Telegram ID.", "error");
                    throw new Error("Enter valid Telegram ID");
                }

                const hasSubscription = Boolean(workState.pendingOverview?.subscription);
                const selectedStatus = normalizeSubscriptionStatus(workPendingSubStatusSelectEl?.value || "active");
                const payload = {
                    telegram_id: telegramId,
                    status: selectedStatus || "active",
                    price_amount: workPendingSubPriceInputEl?.value?.trim() || null,
                    connections_limit: workPendingSubLimitInputEl?.value?.trim() || null,
                };

                if (selectedStatus === "lifetime") {
                    payload.access_until = null;
                } else {
                    const rawDate = String(workPendingSubCreateDateEl?.value || "").trim();
                    try {
                        if (rawDate) {
                            payload.access_until = validateSubscriptionDateValue(rawDate);
                        } else if (!hasSubscription) {
                            payload.access_until = validateSubscriptionDateValue(rawDate);
                        }
                    } catch (err) {
                        setPendingSubscriptionStatus(err?.message || "Невалидная дата подписки.", "error");
                        throw err;
                    }
                }

                let result;
                try {
                    result = await postJson(adminUserSubscriptionByTelegramUrl, payload);
                } catch (err) {
                    setPendingSubscriptionStatus(err?.message || "Не удалось сохранить подписку.", "error");
                    throw err;
                }
                renderPendingSubscriptionOverview(result?.overview || null);
                upsertWorkUserFromOverview(result?.overview || null);
                setPendingSubscriptionStatus(
                    result?.created_user
                        ? "Подписка сохранена. Пользователь создан."
                        : "Подписка сохранена.",
                    "success"
                );
                return result;
            });
        });

        workBindBtnEl?.addEventListener("click", async () => {
            await runWorkAction("Bind Client", async () => {
                const userId = workState.selectedUserId;
                if (!userId) {
                    throw new Error("Open client card first");
                }
                const { panelInboundId, inbound, client } = resolveInboundClientSelection(
                    workInboundSelectEl,
                    workClientSelectEl,
                    workState.clients,
                    "Select inbound and client"
                );

                const payload = {
                    user_id: Number(userId),
                    panel_inbound_id: panelInboundId,
                    client_identifier: client.identifier,
                    protocol: (inbound.protocol || client.protocol || "").toLowerCase(),
                    label: client.label,
                    secret: client.secret,
                    sub_id: client.sub_id,
                };

                const result = await postJson(adminBindClientUrl, payload);
                await loadSelectedUserBindings();
                await loadSelectedUserOverview();
                return result;
            });
        });

        workPendingAddBtnEl?.addEventListener("click", async () => {
            await runWorkAction("Add Pending Binding", async () => {
                const telegramId = String(workPendingTelegramIdEl?.value || "").trim();
                if (!isValidTelegramId(telegramId)) {
                    throw new Error("Enter valid Telegram ID");
                }

                const { panelInboundId, inbound, client } = resolveInboundClientSelection(
                    workPendingInboundSelectEl,
                    workPendingClientSelectEl,
                    workState.pendingClients,
                    "Select inbound and client for pending"
                );

                const payload = {
                    telegram_id: telegramId,
                    panel_inbound_id: panelInboundId,
                    client_identifier: client.identifier,
                    protocol: (inbound.protocol || client.protocol || "").toLowerCase(),
                    label: client.label,
                    secret: client.secret,
                    sub_id: client.sub_id,
                };

                const result = await postJson(adminPendingBindingsUrl, payload);
                await loadPendingBindings(telegramId);
                return result;
            });
        });

        workSubSaveBtnEl?.addEventListener("click", async () => {
            await runWorkAction("Save Subscription", async () => {
                if (!workState.selectedUserId) {
                    throw new Error("Сначала открой карточку клиента");
                }

                const creatingSubscription = !workState.overview?.subscription;
                const selectedStatus = normalizeSubscriptionStatus(workSubStatusSelectEl?.value || "active");
                const payload = {
                    status: selectedStatus || "active",
                    price_amount: workSubPriceInputEl?.value?.trim() || null,
                    connections_limit: workSubLimitInputEl?.value?.trim() || null,
                };
                if (selectedStatus === "lifetime") {
                    payload.access_until = null;
                } else if (creatingSubscription) {
                    payload.access_until = validateSubscriptionDateValue(workSubCreateDateEl?.value);
                }
                const result = await postJson(adminUserSubscriptionUrl(workState.selectedUserId), payload);
                renderWorkClientOverview(result?.overview || null);
                return result;
            });
        });

        workSubExtendBtnEl?.addEventListener("click", async () => {
            await runWorkAction("Extend Subscription", async () => {
                if (!workState.selectedUserId) {
                    throw new Error("Сначала открой карточку клиента");
                }
                const hasSubscription = Boolean(workState.overview?.subscription);
                if (!hasSubscription) {
                    const selectedStatus = normalizeSubscriptionStatus(workSubStatusSelectEl?.value || "active");
                    const payload =
                        selectedStatus === "lifetime"
                            ? { status: "lifetime", access_until: null }
                            : {
                                  status: "active",
                                  access_until: validateSubscriptionDateValue(workSubCreateDateEl?.value),
                              };
                    const result = await postJson(adminUserSubscriptionUrl(workState.selectedUserId), payload);
                    renderWorkClientOverview(result?.overview || null);
                    return result;
                }
                if (isSubscriptionLifetime(workState.overview?.subscription)) {
                    throw new Error("Бессрочную подписку не нужно продлевать");
                }
                const months = Number(workSubExtendRangeEl?.value || 0);
                if (!Number.isInteger(months) || months <= 0) {
                    throw new Error("Выбери срок продления");
                }
                const result = await postJson(adminUserSubscriptionUrl(workState.selectedUserId), {
                    extend_months: months,
                });
                renderWorkClientOverview(result?.overview || null);
                return result;
            });
        });

        workSubExtendRangeEl?.addEventListener("input", () => {
            renderWorkSubExtendValue();
        });
        workSubStatusSelectEl?.addEventListener("change", () => {
            renderWorkSubscriptionControls(workState.overview?.subscription || null);
        });
        renderWorkSubExtendValue();
        updateCloudPageContext(cloudState.path);
        updateCloudUpButton();
</script>
</body>
</html>


